// <auto-generated />

#pragma warning disable xUnit2013

using Loretta.CodeAnalysis.Lua.Syntax;
using Loretta.Utilities;
using Xunit;
using InternalSyntaxFactory = Loretta.CodeAnalysis.Lua.Syntax.InternalSyntax.SyntaxFactory;

namespace Loretta.CodeAnalysis.Lua.UnitTests
{
    public partial class GreenNodeTests
    {
        #region Green Generators
        private static Syntax.InternalSyntax.SkippedTokensTriviaSyntax GenerateSkippedTokensTrivia()
            => InternalSyntaxFactory.SkippedTokensTrivia(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<Syntax.InternalSyntax.SyntaxToken>());

        private static Syntax.InternalSyntax.StatementListSyntax GenerateStatementList()
            => InternalSyntaxFactory.StatementList(SyntaxList<Syntax.InternalSyntax.StatementSyntax>());

        private static Syntax.InternalSyntax.NamedParameterSyntax GenerateNamedParameter()
            => InternalSyntaxFactory.NamedParameter(InternalSyntaxFactory.Identifier("Identifier"), null);

        private static Syntax.InternalSyntax.VarArgParameterSyntax GenerateVarArgParameter()
            => InternalSyntaxFactory.VarArgParameter(InternalSyntaxFactory.Token(SyntaxKind.DotDotDotToken), null);

        private static Syntax.InternalSyntax.ParameterListSyntax GenerateParameterList()
            => InternalSyntaxFactory.ParameterList(InternalSyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), SeparatedSyntaxList<Syntax.InternalSyntax.ParameterSyntax>(), InternalSyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        private static Syntax.InternalSyntax.IdentifierKeyedTableFieldSyntax GenerateIdentifierKeyedTableField()
            => InternalSyntaxFactory.IdentifierKeyedTableField(InternalSyntaxFactory.Identifier("Identifier"), InternalSyntaxFactory.Token(SyntaxKind.EqualsToken), GenerateAnonymousFunctionExpression());

        private static Syntax.InternalSyntax.ExpressionKeyedTableFieldSyntax GenerateExpressionKeyedTableField()
            => InternalSyntaxFactory.ExpressionKeyedTableField(InternalSyntaxFactory.Token(SyntaxKind.OpenBracketToken), GenerateAnonymousFunctionExpression(), InternalSyntaxFactory.Token(SyntaxKind.CloseBracketToken), InternalSyntaxFactory.Token(SyntaxKind.EqualsToken), GenerateAnonymousFunctionExpression());

        private static Syntax.InternalSyntax.UnkeyedTableFieldSyntax GenerateUnkeyedTableField()
            => InternalSyntaxFactory.UnkeyedTableField(GenerateAnonymousFunctionExpression());

        private static Syntax.InternalSyntax.SimpleFunctionNameSyntax GenerateSimpleFunctionName()
            => InternalSyntaxFactory.SimpleFunctionName(InternalSyntaxFactory.Identifier("Name"));

        private static Syntax.InternalSyntax.MemberFunctionNameSyntax GenerateMemberFunctionName()
            => InternalSyntaxFactory.MemberFunctionName(GenerateSimpleFunctionName(), InternalSyntaxFactory.Token(SyntaxKind.DotToken), InternalSyntaxFactory.Identifier("Name"));

        private static Syntax.InternalSyntax.MethodFunctionNameSyntax GenerateMethodFunctionName()
            => InternalSyntaxFactory.MethodFunctionName(GenerateSimpleFunctionName(), InternalSyntaxFactory.Token(SyntaxKind.ColonToken), InternalSyntaxFactory.Identifier("Name"));

        private static Syntax.InternalSyntax.StringFunctionArgumentSyntax GenerateStringFunctionArgument()
            => InternalSyntaxFactory.StringFunctionArgument(GenerateLiteralExpression());

        private static Syntax.InternalSyntax.TableConstructorFunctionArgumentSyntax GenerateTableConstructorFunctionArgument()
            => InternalSyntaxFactory.TableConstructorFunctionArgument(GenerateTableConstructorExpression());

        private static Syntax.InternalSyntax.ExpressionListFunctionArgumentSyntax GenerateExpressionListFunctionArgument()
            => InternalSyntaxFactory.ExpressionListFunctionArgument(InternalSyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), SeparatedSyntaxList<Syntax.InternalSyntax.ExpressionSyntax>(), InternalSyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        private static Syntax.InternalSyntax.AnonymousFunctionExpressionSyntax GenerateAnonymousFunctionExpression()
            => InternalSyntaxFactory.AnonymousFunctionExpression(InternalSyntaxFactory.Token(SyntaxKind.FunctionKeyword), null, GenerateParameterList(), null, GenerateStatementList(), InternalSyntaxFactory.Token(SyntaxKind.EndKeyword));

        private static Syntax.InternalSyntax.TableConstructorExpressionSyntax GenerateTableConstructorExpression()
            => InternalSyntaxFactory.TableConstructorExpression(InternalSyntaxFactory.Token(SyntaxKind.OpenBraceToken), SeparatedSyntaxList<Syntax.InternalSyntax.TableFieldSyntax>(), InternalSyntaxFactory.Token(SyntaxKind.CloseBraceToken));

        private static Syntax.InternalSyntax.LiteralExpressionSyntax GenerateLiteralExpression()
            => InternalSyntaxFactory.LiteralExpression(SyntaxKind.NumericalLiteralExpression, InternalSyntaxFactory.Literal(null, "1", 1, null));

        private static Syntax.InternalSyntax.VarArgExpressionSyntax GenerateVarArgExpression()
            => InternalSyntaxFactory.VarArgExpression(InternalSyntaxFactory.Token(SyntaxKind.DotDotDotToken));

        private static Syntax.InternalSyntax.IdentifierNameSyntax GenerateIdentifierName()
            => InternalSyntaxFactory.IdentifierName(InternalSyntaxFactory.Identifier("Identifier"));

        private static Syntax.InternalSyntax.MemberAccessExpressionSyntax GenerateMemberAccessExpression()
            => InternalSyntaxFactory.MemberAccessExpression(GenerateIdentifierName(), InternalSyntaxFactory.Token(SyntaxKind.DotToken), InternalSyntaxFactory.Identifier("MemberName"));

        private static Syntax.InternalSyntax.ElementAccessExpressionSyntax GenerateElementAccessExpression()
            => InternalSyntaxFactory.ElementAccessExpression(GenerateIdentifierName(), InternalSyntaxFactory.Token(SyntaxKind.OpenBracketToken), GenerateAnonymousFunctionExpression(), InternalSyntaxFactory.Token(SyntaxKind.CloseBracketToken));

        private static Syntax.InternalSyntax.UnaryExpressionSyntax GenerateUnaryExpression()
            => InternalSyntaxFactory.UnaryExpression(SyntaxKind.BitwiseNotExpression, InternalSyntaxFactory.Token(SyntaxKind.BangToken), GenerateAnonymousFunctionExpression());

        private static Syntax.InternalSyntax.BinaryExpressionSyntax GenerateBinaryExpression()
            => InternalSyntaxFactory.BinaryExpression(SyntaxKind.AddExpression, GenerateAnonymousFunctionExpression(), InternalSyntaxFactory.Token(SyntaxKind.AmpersandAmpersandToken), GenerateAnonymousFunctionExpression());

        private static Syntax.InternalSyntax.ElseIfExpressionClauseSyntax GenerateElseIfExpressionClause()
            => InternalSyntaxFactory.ElseIfExpressionClause(InternalSyntaxFactory.Token(SyntaxKind.ElseIfKeyword), GenerateAnonymousFunctionExpression(), InternalSyntaxFactory.Token(SyntaxKind.ThenKeyword), GenerateAnonymousFunctionExpression());

        private static Syntax.InternalSyntax.IfExpressionSyntax GenerateIfExpression()
            => InternalSyntaxFactory.IfExpression(InternalSyntaxFactory.Token(SyntaxKind.IfKeyword), GenerateAnonymousFunctionExpression(), InternalSyntaxFactory.Token(SyntaxKind.ThenKeyword), GenerateAnonymousFunctionExpression(), SyntaxList<Syntax.InternalSyntax.ElseIfExpressionClauseSyntax>(), InternalSyntaxFactory.Token(SyntaxKind.ElseKeyword), GenerateAnonymousFunctionExpression());

        private static Syntax.InternalSyntax.ParenthesizedExpressionSyntax GenerateParenthesizedExpression()
            => InternalSyntaxFactory.ParenthesizedExpression(InternalSyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), GenerateAnonymousFunctionExpression(), InternalSyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        private static Syntax.InternalSyntax.FunctionCallExpressionSyntax GenerateFunctionCallExpression()
            => InternalSyntaxFactory.FunctionCallExpression(GenerateIdentifierName(), GenerateStringFunctionArgument());

        private static Syntax.InternalSyntax.MethodCallExpressionSyntax GenerateMethodCallExpression()
            => InternalSyntaxFactory.MethodCallExpression(GenerateIdentifierName(), InternalSyntaxFactory.Token(SyntaxKind.ColonToken), InternalSyntaxFactory.Identifier("Identifier"), GenerateStringFunctionArgument());

        private static Syntax.InternalSyntax.VariableAttributeSyntax GenerateVariableAttribute()
            => InternalSyntaxFactory.VariableAttribute(InternalSyntaxFactory.Token(SyntaxKind.LessThanToken), InternalSyntaxFactory.Identifier("Identifier"), InternalSyntaxFactory.Token(SyntaxKind.GreaterThanToken));

        private static Syntax.InternalSyntax.LocalDeclarationNameSyntax GenerateLocalDeclarationName()
            => InternalSyntaxFactory.LocalDeclarationName(GenerateIdentifierName(), null, null);

        private static Syntax.InternalSyntax.EqualsValuesClauseSyntax GenerateEqualsValuesClause()
            => InternalSyntaxFactory.EqualsValuesClause(InternalSyntaxFactory.Token(SyntaxKind.EqualsToken), SeparatedSyntaxList<Syntax.InternalSyntax.ExpressionSyntax>(GenerateAnonymousFunctionExpression()));

        private static Syntax.InternalSyntax.AssignmentStatementSyntax GenerateAssignmentStatement()
            => InternalSyntaxFactory.AssignmentStatement(SeparatedSyntaxList<Syntax.InternalSyntax.PrefixExpressionSyntax>(GenerateIdentifierName()), GenerateEqualsValuesClause(), null);

        private static Syntax.InternalSyntax.CompoundAssignmentStatementSyntax GenerateCompoundAssignmentStatement()
            => InternalSyntaxFactory.CompoundAssignmentStatement(SyntaxKind.AddAssignmentStatement, GenerateIdentifierName(), InternalSyntaxFactory.Token(SyntaxKind.PlusEqualsToken), GenerateAnonymousFunctionExpression(), null);

        private static Syntax.InternalSyntax.LocalVariableDeclarationStatementSyntax GenerateLocalVariableDeclarationStatement()
            => InternalSyntaxFactory.LocalVariableDeclarationStatement(InternalSyntaxFactory.Token(SyntaxKind.LocalKeyword), SeparatedSyntaxList<Syntax.InternalSyntax.LocalDeclarationNameSyntax>(GenerateLocalDeclarationName()), null, null);

        private static Syntax.InternalSyntax.TypedIdentifierNameSyntax GenerateTypedIdentifierName()
            => InternalSyntaxFactory.TypedIdentifierName(GenerateIdentifierName(), null);

        private static Syntax.InternalSyntax.NumericForStatementSyntax GenerateNumericForStatement()
            => InternalSyntaxFactory.NumericForStatement(InternalSyntaxFactory.Token(SyntaxKind.ForKeyword), GenerateTypedIdentifierName(), InternalSyntaxFactory.Token(SyntaxKind.EqualsToken), GenerateAnonymousFunctionExpression(), InternalSyntaxFactory.Token(SyntaxKind.CommaToken), GenerateAnonymousFunctionExpression(), null, null, InternalSyntaxFactory.Token(SyntaxKind.DoKeyword), GenerateStatementList(), InternalSyntaxFactory.Token(SyntaxKind.EndKeyword), null);

        private static Syntax.InternalSyntax.GenericForStatementSyntax GenerateGenericForStatement()
            => InternalSyntaxFactory.GenericForStatement(InternalSyntaxFactory.Token(SyntaxKind.ForKeyword), SeparatedSyntaxList<Syntax.InternalSyntax.TypedIdentifierNameSyntax>(GenerateTypedIdentifierName()), InternalSyntaxFactory.Token(SyntaxKind.InKeyword), SeparatedSyntaxList<Syntax.InternalSyntax.ExpressionSyntax>(GenerateAnonymousFunctionExpression()), InternalSyntaxFactory.Token(SyntaxKind.DoKeyword), GenerateStatementList(), InternalSyntaxFactory.Token(SyntaxKind.EndKeyword), null);

        private static Syntax.InternalSyntax.WhileStatementSyntax GenerateWhileStatement()
            => InternalSyntaxFactory.WhileStatement(InternalSyntaxFactory.Token(SyntaxKind.WhileKeyword), GenerateAnonymousFunctionExpression(), InternalSyntaxFactory.Token(SyntaxKind.DoKeyword), GenerateStatementList(), InternalSyntaxFactory.Token(SyntaxKind.EndKeyword), null);

        private static Syntax.InternalSyntax.RepeatUntilStatementSyntax GenerateRepeatUntilStatement()
            => InternalSyntaxFactory.RepeatUntilStatement(InternalSyntaxFactory.Token(SyntaxKind.RepeatKeyword), GenerateStatementList(), InternalSyntaxFactory.Token(SyntaxKind.UntilKeyword), GenerateAnonymousFunctionExpression(), null);

        private static Syntax.InternalSyntax.IfStatementSyntax GenerateIfStatement()
            => InternalSyntaxFactory.IfStatement(InternalSyntaxFactory.Token(SyntaxKind.IfKeyword), GenerateAnonymousFunctionExpression(), InternalSyntaxFactory.Token(SyntaxKind.ThenKeyword), GenerateStatementList(), SyntaxList<Syntax.InternalSyntax.ElseIfClauseSyntax>(), null, InternalSyntaxFactory.Token(SyntaxKind.EndKeyword), null);

        private static Syntax.InternalSyntax.ElseIfClauseSyntax GenerateElseIfClause()
            => InternalSyntaxFactory.ElseIfClause(InternalSyntaxFactory.Token(SyntaxKind.ElseIfKeyword), GenerateAnonymousFunctionExpression(), InternalSyntaxFactory.Token(SyntaxKind.ThenKeyword), GenerateStatementList());

        private static Syntax.InternalSyntax.ElseClauseSyntax GenerateElseClause()
            => InternalSyntaxFactory.ElseClause(InternalSyntaxFactory.Token(SyntaxKind.ElseKeyword), GenerateStatementList());

        private static Syntax.InternalSyntax.GotoStatementSyntax GenerateGotoStatement()
            => InternalSyntaxFactory.GotoStatement(InternalSyntaxFactory.Token(SyntaxKind.GotoKeyword), InternalSyntaxFactory.Identifier("LabelName"), null);

        private static Syntax.InternalSyntax.BreakStatementSyntax GenerateBreakStatement()
            => InternalSyntaxFactory.BreakStatement(InternalSyntaxFactory.Token(SyntaxKind.BreakKeyword), null);

        private static Syntax.InternalSyntax.ReturnStatementSyntax GenerateReturnStatement()
            => InternalSyntaxFactory.ReturnStatement(InternalSyntaxFactory.Token(SyntaxKind.ReturnKeyword), SeparatedSyntaxList<Syntax.InternalSyntax.ExpressionSyntax>(), null);

        private static Syntax.InternalSyntax.ContinueStatementSyntax GenerateContinueStatement()
            => InternalSyntaxFactory.ContinueStatement(InternalSyntaxFactory.Token(SyntaxKind.ContinueKeyword), null);

        private static Syntax.InternalSyntax.LocalFunctionDeclarationStatementSyntax GenerateLocalFunctionDeclarationStatement()
            => InternalSyntaxFactory.LocalFunctionDeclarationStatement(InternalSyntaxFactory.Token(SyntaxKind.LocalKeyword), InternalSyntaxFactory.Token(SyntaxKind.FunctionKeyword), GenerateIdentifierName(), null, GenerateParameterList(), null, GenerateStatementList(), InternalSyntaxFactory.Token(SyntaxKind.EndKeyword), null);

        private static Syntax.InternalSyntax.FunctionDeclarationStatementSyntax GenerateFunctionDeclarationStatement()
            => InternalSyntaxFactory.FunctionDeclarationStatement(InternalSyntaxFactory.Token(SyntaxKind.FunctionKeyword), GenerateSimpleFunctionName(), null, GenerateParameterList(), null, GenerateStatementList(), InternalSyntaxFactory.Token(SyntaxKind.EndKeyword), null);

        private static Syntax.InternalSyntax.DoStatementSyntax GenerateDoStatement()
            => InternalSyntaxFactory.DoStatement(InternalSyntaxFactory.Token(SyntaxKind.DoKeyword), GenerateStatementList(), InternalSyntaxFactory.Token(SyntaxKind.EndKeyword), null);

        private static Syntax.InternalSyntax.GotoLabelStatementSyntax GenerateGotoLabelStatement()
            => InternalSyntaxFactory.GotoLabelStatement(InternalSyntaxFactory.Token(SyntaxKind.ColonColonToken), InternalSyntaxFactory.Identifier("Identifier"), InternalSyntaxFactory.Token(SyntaxKind.ColonColonToken), null);

        private static Syntax.InternalSyntax.ExpressionStatementSyntax GenerateExpressionStatement()
            => InternalSyntaxFactory.ExpressionStatement(GenerateAnonymousFunctionExpression(), null);

        private static Syntax.InternalSyntax.EmptyStatementSyntax GenerateEmptyStatement()
            => InternalSyntaxFactory.EmptyStatement(null);

        private static Syntax.InternalSyntax.TypeDeclarationStatementSyntax GenerateTypeDeclarationStatement()
            => InternalSyntaxFactory.TypeDeclarationStatement(null, InternalSyntaxFactory.Token(SyntaxKind.TypeKeyword), InternalSyntaxFactory.Identifier("Name"), null, InternalSyntaxFactory.Token(SyntaxKind.EqualsToken), GenerateSimpleTypeName(), null);

        private static Syntax.InternalSyntax.TypeBindingSyntax GenerateTypeBinding()
            => InternalSyntaxFactory.TypeBinding(InternalSyntaxFactory.Token(SyntaxKind.ColonToken), GenerateSimpleTypeName());

        private static Syntax.InternalSyntax.SimpleTypeNameSyntax GenerateSimpleTypeName()
            => InternalSyntaxFactory.SimpleTypeName(InternalSyntaxFactory.Identifier("IdentifierToken"), null);

        private static Syntax.InternalSyntax.CompositeTypeNameSyntax GenerateCompositeTypeName()
            => InternalSyntaxFactory.CompositeTypeName(GenerateSimpleTypeName(), InternalSyntaxFactory.Token(SyntaxKind.DotToken), InternalSyntaxFactory.Identifier("IdentifierToken"), null);

        private static Syntax.InternalSyntax.NilableTypeSyntax GenerateNilableType()
            => InternalSyntaxFactory.NilableType(GenerateSimpleTypeName(), InternalSyntaxFactory.Token(SyntaxKind.QuestionToken));

        private static Syntax.InternalSyntax.ParenthesizedTypeSyntax GenerateParenthesizedType()
            => InternalSyntaxFactory.ParenthesizedType(InternalSyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), GenerateSimpleTypeName(), InternalSyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        private static Syntax.InternalSyntax.TypePackSyntax GenerateTypePack()
            => InternalSyntaxFactory.TypePack(InternalSyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), SeparatedSyntaxList<Syntax.InternalSyntax.TypeSyntax>(), InternalSyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        private static Syntax.InternalSyntax.FunctionTypeSyntax GenerateFunctionType()
            => InternalSyntaxFactory.FunctionType(null, InternalSyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), SeparatedSyntaxList<Syntax.InternalSyntax.TypeSyntax>(), InternalSyntaxFactory.Token(SyntaxKind.CloseParenthesisToken), InternalSyntaxFactory.Token(SyntaxKind.MinusGreaterThanToken), GenerateSimpleTypeName());

        private static Syntax.InternalSyntax.ArrayTypeSyntax GenerateArrayType()
            => InternalSyntaxFactory.ArrayType(InternalSyntaxFactory.Token(SyntaxKind.OpenBraceToken), GenerateSimpleTypeName(), InternalSyntaxFactory.Token(SyntaxKind.CloseBraceToken));

        private static Syntax.InternalSyntax.TableTypeIndexerSyntax GenerateTableTypeIndexer()
            => InternalSyntaxFactory.TableTypeIndexer(InternalSyntaxFactory.Token(SyntaxKind.OpenBracketToken), GenerateSimpleTypeName(), InternalSyntaxFactory.Token(SyntaxKind.CloseBracketToken), InternalSyntaxFactory.Token(SyntaxKind.ColonToken), GenerateSimpleTypeName());

        private static Syntax.InternalSyntax.TableTypePropertySyntax GenerateTableTypeProperty()
            => InternalSyntaxFactory.TableTypeProperty(InternalSyntaxFactory.Identifier("Identifier"), InternalSyntaxFactory.Token(SyntaxKind.ColonToken), GenerateSimpleTypeName());

        private static Syntax.InternalSyntax.TableTypeSyntax GenerateTableType()
            => InternalSyntaxFactory.TableType(InternalSyntaxFactory.Token(SyntaxKind.OpenBraceToken), SeparatedSyntaxList<Syntax.InternalSyntax.TableTypeElementSyntax>(), InternalSyntaxFactory.Token(SyntaxKind.CloseBraceToken));

        private static Syntax.InternalSyntax.TypeCastExpressionSyntax GenerateTypeCastExpression()
            => InternalSyntaxFactory.TypeCastExpression(GenerateAnonymousFunctionExpression(), InternalSyntaxFactory.Token(SyntaxKind.ColonColonToken), GenerateSimpleTypeName());

        private static Syntax.InternalSyntax.UnionTypeSyntax GenerateUnionType()
            => InternalSyntaxFactory.UnionType(GenerateSimpleTypeName(), InternalSyntaxFactory.Token(SyntaxKind.PipeToken), GenerateSimpleTypeName());

        private static Syntax.InternalSyntax.IntersectionTypeSyntax GenerateIntersectionType()
            => InternalSyntaxFactory.IntersectionType(GenerateSimpleTypeName(), InternalSyntaxFactory.Token(SyntaxKind.AmpersandToken), GenerateSimpleTypeName());

        private static Syntax.InternalSyntax.EqualsTypeSyntax GenerateEqualsType()
            => InternalSyntaxFactory.EqualsType(InternalSyntaxFactory.Token(SyntaxKind.EqualsToken), GenerateSimpleTypeName());

        private static Syntax.InternalSyntax.TypeParameterSyntax GenerateTypeParameter()
            => InternalSyntaxFactory.TypeParameter(InternalSyntaxFactory.Identifier("Identifier"), null, null);

        private static Syntax.InternalSyntax.TypeParameterListSyntax GenerateTypeParameterList()
            => InternalSyntaxFactory.TypeParameterList(InternalSyntaxFactory.Token(SyntaxKind.LessThanToken), SeparatedSyntaxList<Syntax.InternalSyntax.TypeParameterSyntax>(), InternalSyntaxFactory.Token(SyntaxKind.GreaterThanToken));

        private static Syntax.InternalSyntax.TypeArgumentListSyntax GenerateTypeArgumentList()
            => InternalSyntaxFactory.TypeArgumentList(InternalSyntaxFactory.Token(SyntaxKind.LessThanToken), SeparatedSyntaxList<Syntax.InternalSyntax.TypeSyntax>(), InternalSyntaxFactory.Token(SyntaxKind.GreaterThanToken));

        private static Syntax.InternalSyntax.LiteralTypeSyntax GenerateLiteralType()
            => InternalSyntaxFactory.LiteralType(SyntaxKind.StringType, InternalSyntaxFactory.Literal(null, "string", "string", null));

        private static Syntax.InternalSyntax.TypeofTypeSyntax GenerateTypeofType()
            => InternalSyntaxFactory.TypeofType(InternalSyntaxFactory.Token(SyntaxKind.TypeofKeyword), InternalSyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), GenerateAnonymousFunctionExpression(), InternalSyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        private static Syntax.InternalSyntax.VariadicTypePackSyntax GenerateVariadicTypePack()
            => InternalSyntaxFactory.VariadicTypePack(InternalSyntaxFactory.Token(SyntaxKind.DotDotDotToken), GenerateSimpleTypeName());

        private static Syntax.InternalSyntax.GenericTypePackSyntax GenerateGenericTypePack()
            => InternalSyntaxFactory.GenericTypePack(InternalSyntaxFactory.Identifier("Identifier"), InternalSyntaxFactory.Token(SyntaxKind.DotDotDotToken));

        private static Syntax.InternalSyntax.CompilationUnitSyntax GenerateCompilationUnit()
            => InternalSyntaxFactory.CompilationUnit(GenerateStatementList(), InternalSyntaxFactory.Token(SyntaxKind.EndOfFileToken));
        #endregion Green Generators

        #region Green Factory and Property Tests
        [Fact]
        public void TestSkippedTokensTriviaFactoryAndProperties()
        {
            var node = GenerateSkippedTokensTrivia();

            Assert.Equal(default, node.Tokens);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestStatementListFactoryAndProperties()
        {
            var node = GenerateStatementList();

            Assert.Equal(default, node.Statements);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestNamedParameterFactoryAndProperties()
        {
            var node = GenerateNamedParameter();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind);
            Assert.Null(node.TypeBinding);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestVarArgParameterFactoryAndProperties()
        {
            var node = GenerateVarArgParameter();

            Assert.Equal(SyntaxKind.DotDotDotToken, node.VarArgToken.Kind);
            Assert.Null(node.TypeBinding);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestParameterListFactoryAndProperties()
        {
            var node = GenerateParameterList();

            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind);
            Assert.Equal(default, node.Parameters);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestIdentifierKeyedTableFieldFactoryAndProperties()
        {
            var node = GenerateIdentifierKeyedTableField();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind);
            Assert.Equal(SyntaxKind.EqualsToken, node.EqualsToken.Kind);
            Assert.NotNull(node.Value);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestExpressionKeyedTableFieldFactoryAndProperties()
        {
            var node = GenerateExpressionKeyedTableField();

            Assert.Equal(SyntaxKind.OpenBracketToken, node.OpenBracketToken.Kind);
            Assert.NotNull(node.Key);
            Assert.Equal(SyntaxKind.CloseBracketToken, node.CloseBracketToken.Kind);
            Assert.Equal(SyntaxKind.EqualsToken, node.EqualsToken.Kind);
            Assert.NotNull(node.Value);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestUnkeyedTableFieldFactoryAndProperties()
        {
            var node = GenerateUnkeyedTableField();

            Assert.NotNull(node.Value);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestSimpleFunctionNameFactoryAndProperties()
        {
            var node = GenerateSimpleFunctionName();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Name.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestMemberFunctionNameFactoryAndProperties()
        {
            var node = GenerateMemberFunctionName();

            Assert.NotNull(node.BaseName);
            Assert.Equal(SyntaxKind.DotToken, node.DotToken.Kind);
            Assert.Equal(SyntaxKind.IdentifierToken, node.Name.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestMethodFunctionNameFactoryAndProperties()
        {
            var node = GenerateMethodFunctionName();

            Assert.NotNull(node.BaseName);
            Assert.Equal(SyntaxKind.ColonToken, node.ColonToken.Kind);
            Assert.Equal(SyntaxKind.IdentifierToken, node.Name.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestStringFunctionArgumentFactoryAndProperties()
        {
            var node = GenerateStringFunctionArgument();

            Assert.NotNull(node.Expression);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTableConstructorFunctionArgumentFactoryAndProperties()
        {
            var node = GenerateTableConstructorFunctionArgument();

            Assert.NotNull(node.TableConstructor);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestExpressionListFunctionArgumentFactoryAndProperties()
        {
            var node = GenerateExpressionListFunctionArgument();

            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind);
            Assert.Equal(default, node.Expressions);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestAnonymousFunctionExpressionFactoryAndProperties()
        {
            var node = GenerateAnonymousFunctionExpression();

            Assert.Equal(SyntaxKind.FunctionKeyword, node.FunctionKeyword.Kind);
            Assert.Null(node.TypeParameterList);
            Assert.NotNull(node.Parameters);
            Assert.Null(node.TypeBinding);
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTableConstructorExpressionFactoryAndProperties()
        {
            var node = GenerateTableConstructorExpression();

            Assert.Equal(SyntaxKind.OpenBraceToken, node.OpenBraceToken.Kind);
            Assert.Equal(default, node.Fields);
            Assert.Equal(SyntaxKind.CloseBraceToken, node.CloseBraceToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestLiteralExpressionFactoryAndProperties()
        {
            var node = GenerateLiteralExpression();

            Assert.Equal(SyntaxKind.NumericLiteralToken, node.Token.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestVarArgExpressionFactoryAndProperties()
        {
            var node = GenerateVarArgExpression();

            Assert.Equal(SyntaxKind.DotDotDotToken, node.VarArgToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestIdentifierNameFactoryAndProperties()
        {
            var node = GenerateIdentifierName();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestMemberAccessExpressionFactoryAndProperties()
        {
            var node = GenerateMemberAccessExpression();

            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.DotToken, node.DotSeparator.Kind);
            Assert.Equal(SyntaxKind.IdentifierToken, node.MemberName.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestElementAccessExpressionFactoryAndProperties()
        {
            var node = GenerateElementAccessExpression();

            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.OpenBracketToken, node.OpenBracketToken.Kind);
            Assert.NotNull(node.KeyExpression);
            Assert.Equal(SyntaxKind.CloseBracketToken, node.CloseBracketToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestUnaryExpressionFactoryAndProperties()
        {
            var node = GenerateUnaryExpression();

            Assert.Equal(SyntaxKind.BangToken, node.OperatorToken.Kind);
            Assert.NotNull(node.Operand);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestBinaryExpressionFactoryAndProperties()
        {
            var node = GenerateBinaryExpression();

            Assert.NotNull(node.Left);
            Assert.Equal(SyntaxKind.AmpersandAmpersandToken, node.OperatorToken.Kind);
            Assert.NotNull(node.Right);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestElseIfExpressionClauseFactoryAndProperties()
        {
            var node = GenerateElseIfExpressionClause();

            Assert.Equal(SyntaxKind.ElseIfKeyword, node.ElseIfKeyword.Kind);
            Assert.NotNull(node.Condition);
            Assert.Equal(SyntaxKind.ThenKeyword, node.ThenKeyword.Kind);
            Assert.NotNull(node.Value);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestIfExpressionFactoryAndProperties()
        {
            var node = GenerateIfExpression();

            Assert.Equal(SyntaxKind.IfKeyword, node.IfKeyword.Kind);
            Assert.NotNull(node.Condition);
            Assert.Equal(SyntaxKind.ThenKeyword, node.ThenKeyword.Kind);
            Assert.NotNull(node.TrueValue);
            Assert.Equal(default, node.ElseIfClauses);
            Assert.Equal(SyntaxKind.ElseKeyword, node.ElseKeyword.Kind);
            Assert.NotNull(node.FalseValue);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestParenthesizedExpressionFactoryAndProperties()
        {
            var node = GenerateParenthesizedExpression();

            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind);
            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestFunctionCallExpressionFactoryAndProperties()
        {
            var node = GenerateFunctionCallExpression();

            Assert.NotNull(node.Expression);
            Assert.NotNull(node.Argument);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestMethodCallExpressionFactoryAndProperties()
        {
            var node = GenerateMethodCallExpression();

            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.ColonToken, node.ColonToken.Kind);
            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind);
            Assert.NotNull(node.Argument);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestVariableAttributeFactoryAndProperties()
        {
            var node = GenerateVariableAttribute();

            Assert.Equal(SyntaxKind.LessThanToken, node.LessThanToken.Kind);
            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind);
            Assert.Equal(SyntaxKind.GreaterThanToken, node.GreaterThanToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestLocalDeclarationNameFactoryAndProperties()
        {
            var node = GenerateLocalDeclarationName();

            Assert.NotNull(node.IdentifierName);
            Assert.Null(node.Attribute);
            Assert.Null(node.TypeBinding);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestEqualsValuesClauseFactoryAndProperties()
        {
            var node = GenerateEqualsValuesClause();

            Assert.Equal(SyntaxKind.EqualsToken, node.EqualsToken.Kind);
            Assert.Equal(1, node.Values.Count);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestAssignmentStatementFactoryAndProperties()
        {
            var node = GenerateAssignmentStatement();

            Assert.Equal(1, node.Variables.Count);
            Assert.NotNull(node.EqualsValues);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestCompoundAssignmentStatementFactoryAndProperties()
        {
            var node = GenerateCompoundAssignmentStatement();

            Assert.NotNull(node.Variable);
            Assert.Equal(SyntaxKind.PlusEqualsToken, node.AssignmentOperatorToken.Kind);
            Assert.NotNull(node.Expression);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestLocalVariableDeclarationStatementFactoryAndProperties()
        {
            var node = GenerateLocalVariableDeclarationStatement();

            Assert.Equal(SyntaxKind.LocalKeyword, node.LocalKeyword.Kind);
            Assert.Equal(1, node.Names.Count);
            Assert.Null(node.EqualsValues);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTypedIdentifierNameFactoryAndProperties()
        {
            var node = GenerateTypedIdentifierName();

            Assert.NotNull(node.IdentifierName);
            Assert.Null(node.TypeBinding);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestNumericForStatementFactoryAndProperties()
        {
            var node = GenerateNumericForStatement();

            Assert.Equal(SyntaxKind.ForKeyword, node.ForKeyword.Kind);
            Assert.NotNull(node.Identifier);
            Assert.Equal(SyntaxKind.EqualsToken, node.EqualsToken.Kind);
            Assert.NotNull(node.InitialValue);
            Assert.Equal(SyntaxKind.CommaToken, node.FinalValueCommaToken.Kind);
            Assert.NotNull(node.FinalValue);
            Assert.Null(node.StepValueCommaToken);
            Assert.Null(node.StepValue);
            Assert.Equal(SyntaxKind.DoKeyword, node.DoKeyword.Kind);
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestGenericForStatementFactoryAndProperties()
        {
            var node = GenerateGenericForStatement();

            Assert.Equal(SyntaxKind.ForKeyword, node.ForKeyword.Kind);
            Assert.Equal(1, node.Identifiers.Count);
            Assert.Equal(SyntaxKind.InKeyword, node.InKeyword.Kind);
            Assert.Equal(1, node.Expressions.Count);
            Assert.Equal(SyntaxKind.DoKeyword, node.DoKeyword.Kind);
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestWhileStatementFactoryAndProperties()
        {
            var node = GenerateWhileStatement();

            Assert.Equal(SyntaxKind.WhileKeyword, node.WhileKeyword.Kind);
            Assert.NotNull(node.Condition);
            Assert.Equal(SyntaxKind.DoKeyword, node.DoKeyword.Kind);
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestRepeatUntilStatementFactoryAndProperties()
        {
            var node = GenerateRepeatUntilStatement();

            Assert.Equal(SyntaxKind.RepeatKeyword, node.RepeatKeyword.Kind);
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.UntilKeyword, node.UntilKeyword.Kind);
            Assert.NotNull(node.Condition);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestIfStatementFactoryAndProperties()
        {
            var node = GenerateIfStatement();

            Assert.Equal(SyntaxKind.IfKeyword, node.IfKeyword.Kind);
            Assert.NotNull(node.Condition);
            Assert.Equal(SyntaxKind.ThenKeyword, node.ThenKeyword.Kind);
            Assert.NotNull(node.Body);
            Assert.Equal(default, node.ElseIfClauses);
            Assert.Null(node.ElseClause);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestElseIfClauseFactoryAndProperties()
        {
            var node = GenerateElseIfClause();

            Assert.Equal(SyntaxKind.ElseIfKeyword, node.ElseIfKeyword.Kind);
            Assert.NotNull(node.Condition);
            Assert.Equal(SyntaxKind.ThenKeyword, node.ThenKeyword.Kind);
            Assert.NotNull(node.Body);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestElseClauseFactoryAndProperties()
        {
            var node = GenerateElseClause();

            Assert.Equal(SyntaxKind.ElseKeyword, node.ElseKeyword.Kind);
            Assert.NotNull(node.ElseBody);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestGotoStatementFactoryAndProperties()
        {
            var node = GenerateGotoStatement();

            Assert.Equal(SyntaxKind.GotoKeyword, node.GotoKeyword.Kind);
            Assert.Equal(SyntaxKind.IdentifierToken, node.LabelName.Kind);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestBreakStatementFactoryAndProperties()
        {
            var node = GenerateBreakStatement();

            Assert.Equal(SyntaxKind.BreakKeyword, node.BreakKeyword.Kind);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestReturnStatementFactoryAndProperties()
        {
            var node = GenerateReturnStatement();

            Assert.Equal(SyntaxKind.ReturnKeyword, node.ReturnKeyword.Kind);
            Assert.Equal(default, node.Expressions);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestContinueStatementFactoryAndProperties()
        {
            var node = GenerateContinueStatement();

            Assert.Equal(SyntaxKind.ContinueKeyword, node.ContinueKeyword.Kind);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestLocalFunctionDeclarationStatementFactoryAndProperties()
        {
            var node = GenerateLocalFunctionDeclarationStatement();

            Assert.Equal(SyntaxKind.LocalKeyword, node.LocalKeyword.Kind);
            Assert.Equal(SyntaxKind.FunctionKeyword, node.FunctionKeyword.Kind);
            Assert.NotNull(node.Name);
            Assert.Null(node.TypeParameterList);
            Assert.NotNull(node.Parameters);
            Assert.Null(node.TypeBinding);
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestFunctionDeclarationStatementFactoryAndProperties()
        {
            var node = GenerateFunctionDeclarationStatement();

            Assert.Equal(SyntaxKind.FunctionKeyword, node.FunctionKeyword.Kind);
            Assert.NotNull(node.Name);
            Assert.Null(node.TypeParameterList);
            Assert.NotNull(node.Parameters);
            Assert.Null(node.TypeBinding);
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestDoStatementFactoryAndProperties()
        {
            var node = GenerateDoStatement();

            Assert.Equal(SyntaxKind.DoKeyword, node.DoKeyword.Kind);
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestGotoLabelStatementFactoryAndProperties()
        {
            var node = GenerateGotoLabelStatement();

            Assert.Equal(SyntaxKind.ColonColonToken, node.LeftDelimiterToken.Kind);
            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind);
            Assert.Equal(SyntaxKind.ColonColonToken, node.RightDelimiterToken.Kind);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestExpressionStatementFactoryAndProperties()
        {
            var node = GenerateExpressionStatement();

            Assert.NotNull(node.Expression);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestEmptyStatementFactoryAndProperties()
        {
            var node = GenerateEmptyStatement();

            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTypeDeclarationStatementFactoryAndProperties()
        {
            var node = GenerateTypeDeclarationStatement();

            Assert.Null(node.ExportKeyword);
            Assert.Equal(SyntaxKind.TypeKeyword, node.TypeKeyword.Kind);
            Assert.Equal(SyntaxKind.IdentifierToken, node.Name.Kind);
            Assert.Null(node.TypeParameterList);
            Assert.Equal(SyntaxKind.EqualsToken, node.EqualsToken.Kind);
            Assert.NotNull(node.Type);
            Assert.Null(node.SemicolonToken);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTypeBindingFactoryAndProperties()
        {
            var node = GenerateTypeBinding();

            Assert.Equal(SyntaxKind.ColonToken, node.ColonToken.Kind);
            Assert.NotNull(node.Type);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestSimpleTypeNameFactoryAndProperties()
        {
            var node = GenerateSimpleTypeName();

            Assert.Equal(SyntaxKind.IdentifierToken, node.IdentifierToken.Kind);
            Assert.Null(node.TypeArgumentList);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestCompositeTypeNameFactoryAndProperties()
        {
            var node = GenerateCompositeTypeName();

            Assert.NotNull(node.Base);
            Assert.Equal(SyntaxKind.DotToken, node.DotToken.Kind);
            Assert.Equal(SyntaxKind.IdentifierToken, node.IdentifierToken.Kind);
            Assert.Null(node.TypeArgumentList);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestNilableTypeFactoryAndProperties()
        {
            var node = GenerateNilableType();

            Assert.NotNull(node.Type);
            Assert.Equal(SyntaxKind.QuestionToken, node.QuestionToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestParenthesizedTypeFactoryAndProperties()
        {
            var node = GenerateParenthesizedType();

            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind);
            Assert.NotNull(node.Type);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTypePackFactoryAndProperties()
        {
            var node = GenerateTypePack();

            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind);
            Assert.Equal(default, node.Types);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestFunctionTypeFactoryAndProperties()
        {
            var node = GenerateFunctionType();

            Assert.Null(node.TypeParameterList);
            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind);
            Assert.Equal(default, node.Parameters);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind);
            Assert.Equal(SyntaxKind.MinusGreaterThanToken, node.MinusGreaterThanToken.Kind);
            Assert.NotNull(node.ReturnType);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestArrayTypeFactoryAndProperties()
        {
            var node = GenerateArrayType();

            Assert.Equal(SyntaxKind.OpenBraceToken, node.OpenBraceToken.Kind);
            Assert.NotNull(node.Type);
            Assert.Equal(SyntaxKind.CloseBraceToken, node.CloseBraceToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTableTypeIndexerFactoryAndProperties()
        {
            var node = GenerateTableTypeIndexer();

            Assert.Equal(SyntaxKind.OpenBracketToken, node.OpenBracketToken.Kind);
            Assert.NotNull(node.IndexType);
            Assert.Equal(SyntaxKind.CloseBracketToken, node.CloseBracketToken.Kind);
            Assert.Equal(SyntaxKind.ColonToken, node.ColonToken.Kind);
            Assert.NotNull(node.ValueType);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTableTypePropertyFactoryAndProperties()
        {
            var node = GenerateTableTypeProperty();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind);
            Assert.Equal(SyntaxKind.ColonToken, node.ColonToken.Kind);
            Assert.NotNull(node.ValueType);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTableTypeFactoryAndProperties()
        {
            var node = GenerateTableType();

            Assert.Equal(SyntaxKind.OpenBraceToken, node.OpenBraceToken.Kind);
            Assert.Equal(default, node.Elements);
            Assert.Equal(SyntaxKind.CloseBraceToken, node.CloseBraceToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTypeCastExpressionFactoryAndProperties()
        {
            var node = GenerateTypeCastExpression();

            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.ColonColonToken, node.ColonColonToken.Kind);
            Assert.NotNull(node.Type);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestUnionTypeFactoryAndProperties()
        {
            var node = GenerateUnionType();

            Assert.NotNull(node.Left);
            Assert.Equal(SyntaxKind.PipeToken, node.PipeToken.Kind);
            Assert.NotNull(node.Right);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestIntersectionTypeFactoryAndProperties()
        {
            var node = GenerateIntersectionType();

            Assert.NotNull(node.Left);
            Assert.Equal(SyntaxKind.AmpersandToken, node.AmpersandToken.Kind);
            Assert.NotNull(node.Right);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestEqualsTypeFactoryAndProperties()
        {
            var node = GenerateEqualsType();

            Assert.Equal(SyntaxKind.EqualsToken, node.EqualsToken.Kind);
            Assert.NotNull(node.Type);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTypeParameterFactoryAndProperties()
        {
            var node = GenerateTypeParameter();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind);
            Assert.Null(node.DotDotDotToken);
            Assert.Null(node.EqualsType);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTypeParameterListFactoryAndProperties()
        {
            var node = GenerateTypeParameterList();

            Assert.Equal(SyntaxKind.LessThanToken, node.LessThanToken.Kind);
            Assert.Equal(default, node.Names);
            Assert.Equal(SyntaxKind.GreaterThanToken, node.GreaterThanToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTypeArgumentListFactoryAndProperties()
        {
            var node = GenerateTypeArgumentList();

            Assert.Equal(SyntaxKind.LessThanToken, node.LessThanToken.Kind);
            Assert.Equal(default, node.Arguments);
            Assert.Equal(SyntaxKind.GreaterThanToken, node.GreaterThanToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestLiteralTypeFactoryAndProperties()
        {
            var node = GenerateLiteralType();

            Assert.Equal(SyntaxKind.StringLiteralToken, node.Token.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestTypeofTypeFactoryAndProperties()
        {
            var node = GenerateTypeofType();

            Assert.Equal(SyntaxKind.TypeofKeyword, node.TypeofKeyword.Kind);
            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind);
            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestVariadicTypePackFactoryAndProperties()
        {
            var node = GenerateVariadicTypePack();

            Assert.Equal(SyntaxKind.DotDotDotToken, node.DotDotDotToken.Kind);
            Assert.NotNull(node.Type);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestGenericTypePackFactoryAndProperties()
        {
            var node = GenerateGenericTypePack();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind);
            Assert.Equal(SyntaxKind.DotDotDotToken, node.DotDotDotToken.Kind);

            AttachAndCheckDiagnostics(node);
        }

        [Fact]
        public void TestCompilationUnitFactoryAndProperties()
        {
            var node = GenerateCompilationUnit();

            Assert.NotNull(node.Statements);
            Assert.Equal(SyntaxKind.EndOfFileToken, node.EndOfFileToken.Kind);

            AttachAndCheckDiagnostics(node);
        }
        #endregion Green Factory and Property Tests

        #region Green Rewriters
        [Fact]
        public void TestSkippedTokensTriviaTokenDeleteRewriter()
        {
            var oldNode = GenerateSkippedTokensTrivia();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestSkippedTokensTriviaIdentityRewriter()
        {
            var oldNode = GenerateSkippedTokensTrivia();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestStatementListTokenDeleteRewriter()
        {
            var oldNode = GenerateStatementList();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestStatementListIdentityRewriter()
        {
            var oldNode = GenerateStatementList();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestNamedParameterTokenDeleteRewriter()
        {
            var oldNode = GenerateNamedParameter();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestNamedParameterIdentityRewriter()
        {
            var oldNode = GenerateNamedParameter();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestVarArgParameterTokenDeleteRewriter()
        {
            var oldNode = GenerateVarArgParameter();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestVarArgParameterIdentityRewriter()
        {
            var oldNode = GenerateVarArgParameter();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestParameterListTokenDeleteRewriter()
        {
            var oldNode = GenerateParameterList();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestParameterListIdentityRewriter()
        {
            var oldNode = GenerateParameterList();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestIdentifierKeyedTableFieldTokenDeleteRewriter()
        {
            var oldNode = GenerateIdentifierKeyedTableField();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestIdentifierKeyedTableFieldIdentityRewriter()
        {
            var oldNode = GenerateIdentifierKeyedTableField();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestExpressionKeyedTableFieldTokenDeleteRewriter()
        {
            var oldNode = GenerateExpressionKeyedTableField();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestExpressionKeyedTableFieldIdentityRewriter()
        {
            var oldNode = GenerateExpressionKeyedTableField();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestUnkeyedTableFieldTokenDeleteRewriter()
        {
            var oldNode = GenerateUnkeyedTableField();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestUnkeyedTableFieldIdentityRewriter()
        {
            var oldNode = GenerateUnkeyedTableField();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestSimpleFunctionNameTokenDeleteRewriter()
        {
            var oldNode = GenerateSimpleFunctionName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestSimpleFunctionNameIdentityRewriter()
        {
            var oldNode = GenerateSimpleFunctionName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestMemberFunctionNameTokenDeleteRewriter()
        {
            var oldNode = GenerateMemberFunctionName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestMemberFunctionNameIdentityRewriter()
        {
            var oldNode = GenerateMemberFunctionName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestMethodFunctionNameTokenDeleteRewriter()
        {
            var oldNode = GenerateMethodFunctionName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestMethodFunctionNameIdentityRewriter()
        {
            var oldNode = GenerateMethodFunctionName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestStringFunctionArgumentTokenDeleteRewriter()
        {
            var oldNode = GenerateStringFunctionArgument();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestStringFunctionArgumentIdentityRewriter()
        {
            var oldNode = GenerateStringFunctionArgument();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTableConstructorFunctionArgumentTokenDeleteRewriter()
        {
            var oldNode = GenerateTableConstructorFunctionArgument();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTableConstructorFunctionArgumentIdentityRewriter()
        {
            var oldNode = GenerateTableConstructorFunctionArgument();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestExpressionListFunctionArgumentTokenDeleteRewriter()
        {
            var oldNode = GenerateExpressionListFunctionArgument();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestExpressionListFunctionArgumentIdentityRewriter()
        {
            var oldNode = GenerateExpressionListFunctionArgument();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestAnonymousFunctionExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateAnonymousFunctionExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestAnonymousFunctionExpressionIdentityRewriter()
        {
            var oldNode = GenerateAnonymousFunctionExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTableConstructorExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateTableConstructorExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTableConstructorExpressionIdentityRewriter()
        {
            var oldNode = GenerateTableConstructorExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestLiteralExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateLiteralExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestLiteralExpressionIdentityRewriter()
        {
            var oldNode = GenerateLiteralExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestVarArgExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateVarArgExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestVarArgExpressionIdentityRewriter()
        {
            var oldNode = GenerateVarArgExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestIdentifierNameTokenDeleteRewriter()
        {
            var oldNode = GenerateIdentifierName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestIdentifierNameIdentityRewriter()
        {
            var oldNode = GenerateIdentifierName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestMemberAccessExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateMemberAccessExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestMemberAccessExpressionIdentityRewriter()
        {
            var oldNode = GenerateMemberAccessExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestElementAccessExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateElementAccessExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestElementAccessExpressionIdentityRewriter()
        {
            var oldNode = GenerateElementAccessExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestUnaryExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateUnaryExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestUnaryExpressionIdentityRewriter()
        {
            var oldNode = GenerateUnaryExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestBinaryExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateBinaryExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestBinaryExpressionIdentityRewriter()
        {
            var oldNode = GenerateBinaryExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestElseIfExpressionClauseTokenDeleteRewriter()
        {
            var oldNode = GenerateElseIfExpressionClause();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestElseIfExpressionClauseIdentityRewriter()
        {
            var oldNode = GenerateElseIfExpressionClause();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestIfExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateIfExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestIfExpressionIdentityRewriter()
        {
            var oldNode = GenerateIfExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestParenthesizedExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateParenthesizedExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestParenthesizedExpressionIdentityRewriter()
        {
            var oldNode = GenerateParenthesizedExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestFunctionCallExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateFunctionCallExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestFunctionCallExpressionIdentityRewriter()
        {
            var oldNode = GenerateFunctionCallExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestMethodCallExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateMethodCallExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestMethodCallExpressionIdentityRewriter()
        {
            var oldNode = GenerateMethodCallExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestVariableAttributeTokenDeleteRewriter()
        {
            var oldNode = GenerateVariableAttribute();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestVariableAttributeIdentityRewriter()
        {
            var oldNode = GenerateVariableAttribute();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestLocalDeclarationNameTokenDeleteRewriter()
        {
            var oldNode = GenerateLocalDeclarationName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestLocalDeclarationNameIdentityRewriter()
        {
            var oldNode = GenerateLocalDeclarationName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestEqualsValuesClauseTokenDeleteRewriter()
        {
            var oldNode = GenerateEqualsValuesClause();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestEqualsValuesClauseIdentityRewriter()
        {
            var oldNode = GenerateEqualsValuesClause();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestAssignmentStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateAssignmentStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestAssignmentStatementIdentityRewriter()
        {
            var oldNode = GenerateAssignmentStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestCompoundAssignmentStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateCompoundAssignmentStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestCompoundAssignmentStatementIdentityRewriter()
        {
            var oldNode = GenerateCompoundAssignmentStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestLocalVariableDeclarationStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateLocalVariableDeclarationStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestLocalVariableDeclarationStatementIdentityRewriter()
        {
            var oldNode = GenerateLocalVariableDeclarationStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypedIdentifierNameTokenDeleteRewriter()
        {
            var oldNode = GenerateTypedIdentifierName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypedIdentifierNameIdentityRewriter()
        {
            var oldNode = GenerateTypedIdentifierName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestNumericForStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateNumericForStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestNumericForStatementIdentityRewriter()
        {
            var oldNode = GenerateNumericForStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestGenericForStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateGenericForStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestGenericForStatementIdentityRewriter()
        {
            var oldNode = GenerateGenericForStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestWhileStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateWhileStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestWhileStatementIdentityRewriter()
        {
            var oldNode = GenerateWhileStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestRepeatUntilStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateRepeatUntilStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestRepeatUntilStatementIdentityRewriter()
        {
            var oldNode = GenerateRepeatUntilStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestIfStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateIfStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestIfStatementIdentityRewriter()
        {
            var oldNode = GenerateIfStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestElseIfClauseTokenDeleteRewriter()
        {
            var oldNode = GenerateElseIfClause();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestElseIfClauseIdentityRewriter()
        {
            var oldNode = GenerateElseIfClause();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestElseClauseTokenDeleteRewriter()
        {
            var oldNode = GenerateElseClause();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestElseClauseIdentityRewriter()
        {
            var oldNode = GenerateElseClause();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestGotoStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateGotoStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestGotoStatementIdentityRewriter()
        {
            var oldNode = GenerateGotoStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestBreakStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateBreakStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestBreakStatementIdentityRewriter()
        {
            var oldNode = GenerateBreakStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestReturnStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateReturnStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestReturnStatementIdentityRewriter()
        {
            var oldNode = GenerateReturnStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestContinueStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateContinueStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestContinueStatementIdentityRewriter()
        {
            var oldNode = GenerateContinueStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestLocalFunctionDeclarationStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateLocalFunctionDeclarationStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestLocalFunctionDeclarationStatementIdentityRewriter()
        {
            var oldNode = GenerateLocalFunctionDeclarationStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestFunctionDeclarationStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateFunctionDeclarationStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestFunctionDeclarationStatementIdentityRewriter()
        {
            var oldNode = GenerateFunctionDeclarationStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestDoStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateDoStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestDoStatementIdentityRewriter()
        {
            var oldNode = GenerateDoStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestGotoLabelStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateGotoLabelStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestGotoLabelStatementIdentityRewriter()
        {
            var oldNode = GenerateGotoLabelStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestExpressionStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateExpressionStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestExpressionStatementIdentityRewriter()
        {
            var oldNode = GenerateExpressionStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestEmptyStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateEmptyStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestEmptyStatementIdentityRewriter()
        {
            var oldNode = GenerateEmptyStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeDeclarationStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeDeclarationStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeDeclarationStatementIdentityRewriter()
        {
            var oldNode = GenerateTypeDeclarationStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeBindingTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeBinding();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeBindingIdentityRewriter()
        {
            var oldNode = GenerateTypeBinding();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestSimpleTypeNameTokenDeleteRewriter()
        {
            var oldNode = GenerateSimpleTypeName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestSimpleTypeNameIdentityRewriter()
        {
            var oldNode = GenerateSimpleTypeName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestCompositeTypeNameTokenDeleteRewriter()
        {
            var oldNode = GenerateCompositeTypeName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestCompositeTypeNameIdentityRewriter()
        {
            var oldNode = GenerateCompositeTypeName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestNilableTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateNilableType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestNilableTypeIdentityRewriter()
        {
            var oldNode = GenerateNilableType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestParenthesizedTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateParenthesizedType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestParenthesizedTypeIdentityRewriter()
        {
            var oldNode = GenerateParenthesizedType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypePackTokenDeleteRewriter()
        {
            var oldNode = GenerateTypePack();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypePackIdentityRewriter()
        {
            var oldNode = GenerateTypePack();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestFunctionTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateFunctionType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestFunctionTypeIdentityRewriter()
        {
            var oldNode = GenerateFunctionType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestArrayTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateArrayType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestArrayTypeIdentityRewriter()
        {
            var oldNode = GenerateArrayType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTableTypeIndexerTokenDeleteRewriter()
        {
            var oldNode = GenerateTableTypeIndexer();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTableTypeIndexerIdentityRewriter()
        {
            var oldNode = GenerateTableTypeIndexer();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTableTypePropertyTokenDeleteRewriter()
        {
            var oldNode = GenerateTableTypeProperty();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTableTypePropertyIdentityRewriter()
        {
            var oldNode = GenerateTableTypeProperty();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTableTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateTableType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTableTypeIdentityRewriter()
        {
            var oldNode = GenerateTableType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeCastExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeCastExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeCastExpressionIdentityRewriter()
        {
            var oldNode = GenerateTypeCastExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestUnionTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateUnionType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestUnionTypeIdentityRewriter()
        {
            var oldNode = GenerateUnionType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestIntersectionTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateIntersectionType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestIntersectionTypeIdentityRewriter()
        {
            var oldNode = GenerateIntersectionType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestEqualsTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateEqualsType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestEqualsTypeIdentityRewriter()
        {
            var oldNode = GenerateEqualsType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeParameterTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeParameter();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeParameterIdentityRewriter()
        {
            var oldNode = GenerateTypeParameter();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeParameterListTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeParameterList();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeParameterListIdentityRewriter()
        {
            var oldNode = GenerateTypeParameterList();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeArgumentListTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeArgumentList();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeArgumentListIdentityRewriter()
        {
            var oldNode = GenerateTypeArgumentList();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestLiteralTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateLiteralType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestLiteralTypeIdentityRewriter()
        {
            var oldNode = GenerateLiteralType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeofTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeofType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeofTypeIdentityRewriter()
        {
            var oldNode = GenerateTypeofType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestVariadicTypePackTokenDeleteRewriter()
        {
            var oldNode = GenerateVariadicTypePack();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestVariadicTypePackIdentityRewriter()
        {
            var oldNode = GenerateVariadicTypePack();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestGenericTypePackTokenDeleteRewriter()
        {
            var oldNode = GenerateGenericTypePack();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestGenericTypePackIdentityRewriter()
        {
            var oldNode = GenerateGenericTypePack();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestCompilationUnitTokenDeleteRewriter()
        {
            var oldNode = GenerateCompilationUnit();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestCompilationUnitIdentityRewriter()
        {
            var oldNode = GenerateCompilationUnit();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }
        #endregion Green Rewriters
    }

    public partial class RedNodeTests
    {
        #region Red Generators
        private static SkippedTokensTriviaSyntax GenerateSkippedTokensTrivia()
            => SyntaxFactory.SkippedTokensTrivia(new SyntaxTokenList());

        private static StatementListSyntax GenerateStatementList()
            => SyntaxFactory.StatementList(SyntaxList<StatementSyntax>());

        private static NamedParameterSyntax GenerateNamedParameter()
            => SyntaxFactory.NamedParameter(SyntaxFactory.Identifier("Identifier"), default(TypeBindingSyntax));

        private static VarArgParameterSyntax GenerateVarArgParameter()
            => SyntaxFactory.VarArgParameter(SyntaxFactory.Token(SyntaxKind.DotDotDotToken), default(TypeBindingSyntax));

        private static ParameterListSyntax GenerateParameterList()
            => SyntaxFactory.ParameterList(SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), SeparatedSyntaxList<ParameterSyntax>(), SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        private static IdentifierKeyedTableFieldSyntax GenerateIdentifierKeyedTableField()
            => SyntaxFactory.IdentifierKeyedTableField(SyntaxFactory.Identifier("Identifier"), SyntaxFactory.Token(SyntaxKind.EqualsToken), GenerateAnonymousFunctionExpression());

        private static ExpressionKeyedTableFieldSyntax GenerateExpressionKeyedTableField()
            => SyntaxFactory.ExpressionKeyedTableField(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), GenerateAnonymousFunctionExpression(), SyntaxFactory.Token(SyntaxKind.CloseBracketToken), SyntaxFactory.Token(SyntaxKind.EqualsToken), GenerateAnonymousFunctionExpression());

        private static UnkeyedTableFieldSyntax GenerateUnkeyedTableField()
            => SyntaxFactory.UnkeyedTableField(GenerateAnonymousFunctionExpression());

        private static SimpleFunctionNameSyntax GenerateSimpleFunctionName()
            => SyntaxFactory.SimpleFunctionName(SyntaxFactory.Identifier("Name"));

        private static MemberFunctionNameSyntax GenerateMemberFunctionName()
            => SyntaxFactory.MemberFunctionName(GenerateSimpleFunctionName(), SyntaxFactory.Token(SyntaxKind.DotToken), SyntaxFactory.Identifier("Name"));

        private static MethodFunctionNameSyntax GenerateMethodFunctionName()
            => SyntaxFactory.MethodFunctionName(GenerateSimpleFunctionName(), SyntaxFactory.Token(SyntaxKind.ColonToken), SyntaxFactory.Identifier("Name"));

        private static StringFunctionArgumentSyntax GenerateStringFunctionArgument()
            => SyntaxFactory.StringFunctionArgument(GenerateLiteralExpression());

        private static TableConstructorFunctionArgumentSyntax GenerateTableConstructorFunctionArgument()
            => SyntaxFactory.TableConstructorFunctionArgument(GenerateTableConstructorExpression());

        private static ExpressionListFunctionArgumentSyntax GenerateExpressionListFunctionArgument()
            => SyntaxFactory.ExpressionListFunctionArgument(SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), SeparatedSyntaxList<ExpressionSyntax>(), SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        private static AnonymousFunctionExpressionSyntax GenerateAnonymousFunctionExpression()
            => SyntaxFactory.AnonymousFunctionExpression(SyntaxFactory.Token(SyntaxKind.FunctionKeyword), default(TypeParameterListSyntax), GenerateParameterList(), default(TypeBindingSyntax), GenerateStatementList(), SyntaxFactory.Token(SyntaxKind.EndKeyword));

        private static TableConstructorExpressionSyntax GenerateTableConstructorExpression()
            => SyntaxFactory.TableConstructorExpression(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), SeparatedSyntaxList<TableFieldSyntax>(), SyntaxFactory.Token(SyntaxKind.CloseBraceToken));

        private static LiteralExpressionSyntax GenerateLiteralExpression()
            => SyntaxFactory.LiteralExpression(SyntaxKind.NumericalLiteralExpression, SyntaxFactory.Literal("1", 1));

        private static VarArgExpressionSyntax GenerateVarArgExpression()
            => SyntaxFactory.VarArgExpression(SyntaxFactory.Token(SyntaxKind.DotDotDotToken));

        private static IdentifierNameSyntax GenerateIdentifierName()
            => SyntaxFactory.IdentifierName(SyntaxFactory.Identifier("Identifier"));

        private static MemberAccessExpressionSyntax GenerateMemberAccessExpression()
            => SyntaxFactory.MemberAccessExpression(GenerateIdentifierName(), SyntaxFactory.Token(SyntaxKind.DotToken), SyntaxFactory.Identifier("MemberName"));

        private static ElementAccessExpressionSyntax GenerateElementAccessExpression()
            => SyntaxFactory.ElementAccessExpression(GenerateIdentifierName(), SyntaxFactory.Token(SyntaxKind.OpenBracketToken), GenerateAnonymousFunctionExpression(), SyntaxFactory.Token(SyntaxKind.CloseBracketToken));

        private static UnaryExpressionSyntax GenerateUnaryExpression()
            => SyntaxFactory.UnaryExpression(SyntaxKind.BitwiseNotExpression, SyntaxFactory.Token(SyntaxKind.BangToken), GenerateAnonymousFunctionExpression());

        private static BinaryExpressionSyntax GenerateBinaryExpression()
            => SyntaxFactory.BinaryExpression(SyntaxKind.AddExpression, GenerateAnonymousFunctionExpression(), SyntaxFactory.Token(SyntaxKind.AmpersandAmpersandToken), GenerateAnonymousFunctionExpression());

        private static ElseIfExpressionClauseSyntax GenerateElseIfExpressionClause()
            => SyntaxFactory.ElseIfExpressionClause(SyntaxFactory.Token(SyntaxKind.ElseIfKeyword), GenerateAnonymousFunctionExpression(), SyntaxFactory.Token(SyntaxKind.ThenKeyword), GenerateAnonymousFunctionExpression());

        private static IfExpressionSyntax GenerateIfExpression()
            => SyntaxFactory.IfExpression(SyntaxFactory.Token(SyntaxKind.IfKeyword), GenerateAnonymousFunctionExpression(), SyntaxFactory.Token(SyntaxKind.ThenKeyword), GenerateAnonymousFunctionExpression(), SyntaxList<ElseIfExpressionClauseSyntax>(), SyntaxFactory.Token(SyntaxKind.ElseKeyword), GenerateAnonymousFunctionExpression());

        private static ParenthesizedExpressionSyntax GenerateParenthesizedExpression()
            => SyntaxFactory.ParenthesizedExpression(SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), GenerateAnonymousFunctionExpression(), SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        private static FunctionCallExpressionSyntax GenerateFunctionCallExpression()
            => SyntaxFactory.FunctionCallExpression(GenerateIdentifierName(), GenerateStringFunctionArgument());

        private static MethodCallExpressionSyntax GenerateMethodCallExpression()
            => SyntaxFactory.MethodCallExpression(GenerateIdentifierName(), SyntaxFactory.Token(SyntaxKind.ColonToken), SyntaxFactory.Identifier("Identifier"), GenerateStringFunctionArgument());

        private static VariableAttributeSyntax GenerateVariableAttribute()
            => SyntaxFactory.VariableAttribute(SyntaxFactory.Token(SyntaxKind.LessThanToken), SyntaxFactory.Identifier("Identifier"), SyntaxFactory.Token(SyntaxKind.GreaterThanToken));

        private static LocalDeclarationNameSyntax GenerateLocalDeclarationName()
            => SyntaxFactory.LocalDeclarationName(GenerateIdentifierName(), default(VariableAttributeSyntax), default(TypeBindingSyntax));

        private static EqualsValuesClauseSyntax GenerateEqualsValuesClause()
            => SyntaxFactory.EqualsValuesClause(SyntaxFactory.Token(SyntaxKind.EqualsToken), SeparatedSyntaxList<ExpressionSyntax>(GenerateAnonymousFunctionExpression()));

        private static AssignmentStatementSyntax GenerateAssignmentStatement()
            => SyntaxFactory.AssignmentStatement(SeparatedSyntaxList<PrefixExpressionSyntax>(GenerateIdentifierName()), GenerateEqualsValuesClause(), default(SyntaxToken));

        private static CompoundAssignmentStatementSyntax GenerateCompoundAssignmentStatement()
            => SyntaxFactory.CompoundAssignmentStatement(SyntaxKind.AddAssignmentStatement, GenerateIdentifierName(), SyntaxFactory.Token(SyntaxKind.PlusEqualsToken), GenerateAnonymousFunctionExpression(), default(SyntaxToken));

        private static LocalVariableDeclarationStatementSyntax GenerateLocalVariableDeclarationStatement()
            => SyntaxFactory.LocalVariableDeclarationStatement(SyntaxFactory.Token(SyntaxKind.LocalKeyword), SeparatedSyntaxList<LocalDeclarationNameSyntax>(GenerateLocalDeclarationName()), default(EqualsValuesClauseSyntax), default(SyntaxToken));

        private static TypedIdentifierNameSyntax GenerateTypedIdentifierName()
            => SyntaxFactory.TypedIdentifierName(GenerateIdentifierName(), default(TypeBindingSyntax));

        private static NumericForStatementSyntax GenerateNumericForStatement()
            => SyntaxFactory.NumericForStatement(SyntaxFactory.Token(SyntaxKind.ForKeyword), GenerateTypedIdentifierName(), SyntaxFactory.Token(SyntaxKind.EqualsToken), GenerateAnonymousFunctionExpression(), SyntaxFactory.Token(SyntaxKind.CommaToken), GenerateAnonymousFunctionExpression(), default(SyntaxToken), default(ExpressionSyntax), SyntaxFactory.Token(SyntaxKind.DoKeyword), GenerateStatementList(), SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        private static GenericForStatementSyntax GenerateGenericForStatement()
            => SyntaxFactory.GenericForStatement(SyntaxFactory.Token(SyntaxKind.ForKeyword), SeparatedSyntaxList<TypedIdentifierNameSyntax>(GenerateTypedIdentifierName()), SyntaxFactory.Token(SyntaxKind.InKeyword), SeparatedSyntaxList<ExpressionSyntax>(GenerateAnonymousFunctionExpression()), SyntaxFactory.Token(SyntaxKind.DoKeyword), GenerateStatementList(), SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        private static WhileStatementSyntax GenerateWhileStatement()
            => SyntaxFactory.WhileStatement(SyntaxFactory.Token(SyntaxKind.WhileKeyword), GenerateAnonymousFunctionExpression(), SyntaxFactory.Token(SyntaxKind.DoKeyword), GenerateStatementList(), SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        private static RepeatUntilStatementSyntax GenerateRepeatUntilStatement()
            => SyntaxFactory.RepeatUntilStatement(SyntaxFactory.Token(SyntaxKind.RepeatKeyword), GenerateStatementList(), SyntaxFactory.Token(SyntaxKind.UntilKeyword), GenerateAnonymousFunctionExpression(), default(SyntaxToken));

        private static IfStatementSyntax GenerateIfStatement()
            => SyntaxFactory.IfStatement(SyntaxFactory.Token(SyntaxKind.IfKeyword), GenerateAnonymousFunctionExpression(), SyntaxFactory.Token(SyntaxKind.ThenKeyword), GenerateStatementList(), SyntaxList<ElseIfClauseSyntax>(), default(ElseClauseSyntax), SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        private static ElseIfClauseSyntax GenerateElseIfClause()
            => SyntaxFactory.ElseIfClause(SyntaxFactory.Token(SyntaxKind.ElseIfKeyword), GenerateAnonymousFunctionExpression(), SyntaxFactory.Token(SyntaxKind.ThenKeyword), GenerateStatementList());

        private static ElseClauseSyntax GenerateElseClause()
            => SyntaxFactory.ElseClause(SyntaxFactory.Token(SyntaxKind.ElseKeyword), GenerateStatementList());

        private static GotoStatementSyntax GenerateGotoStatement()
            => SyntaxFactory.GotoStatement(SyntaxFactory.Token(SyntaxKind.GotoKeyword), SyntaxFactory.Identifier("LabelName"), default(SyntaxToken));

        private static BreakStatementSyntax GenerateBreakStatement()
            => SyntaxFactory.BreakStatement(SyntaxFactory.Token(SyntaxKind.BreakKeyword), default(SyntaxToken));

        private static ReturnStatementSyntax GenerateReturnStatement()
            => SyntaxFactory.ReturnStatement(SyntaxFactory.Token(SyntaxKind.ReturnKeyword), SeparatedSyntaxList<ExpressionSyntax>(), default(SyntaxToken));

        private static ContinueStatementSyntax GenerateContinueStatement()
            => SyntaxFactory.ContinueStatement(SyntaxFactory.Token(SyntaxKind.ContinueKeyword), default(SyntaxToken));

        private static LocalFunctionDeclarationStatementSyntax GenerateLocalFunctionDeclarationStatement()
            => SyntaxFactory.LocalFunctionDeclarationStatement(SyntaxFactory.Token(SyntaxKind.LocalKeyword), SyntaxFactory.Token(SyntaxKind.FunctionKeyword), GenerateIdentifierName(), default(TypeParameterListSyntax), GenerateParameterList(), default(TypeBindingSyntax), GenerateStatementList(), SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        private static FunctionDeclarationStatementSyntax GenerateFunctionDeclarationStatement()
            => SyntaxFactory.FunctionDeclarationStatement(SyntaxFactory.Token(SyntaxKind.FunctionKeyword), GenerateSimpleFunctionName(), default(TypeParameterListSyntax), GenerateParameterList(), default(TypeBindingSyntax), GenerateStatementList(), SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        private static DoStatementSyntax GenerateDoStatement()
            => SyntaxFactory.DoStatement(SyntaxFactory.Token(SyntaxKind.DoKeyword), GenerateStatementList(), SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        private static GotoLabelStatementSyntax GenerateGotoLabelStatement()
            => SyntaxFactory.GotoLabelStatement(SyntaxFactory.Token(SyntaxKind.ColonColonToken), SyntaxFactory.Identifier("Identifier"), SyntaxFactory.Token(SyntaxKind.ColonColonToken), default(SyntaxToken));

        private static ExpressionStatementSyntax GenerateExpressionStatement()
            => SyntaxFactory.ExpressionStatement(GenerateAnonymousFunctionExpression(), default(SyntaxToken));

        private static EmptyStatementSyntax GenerateEmptyStatement()
            => SyntaxFactory.EmptyStatement(default(SyntaxToken));

        private static TypeDeclarationStatementSyntax GenerateTypeDeclarationStatement()
            => SyntaxFactory.TypeDeclarationStatement(default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.TypeKeyword), SyntaxFactory.Identifier("Name"), default(TypeParameterListSyntax), SyntaxFactory.Token(SyntaxKind.EqualsToken), GenerateSimpleTypeName(), default(SyntaxToken));

        private static TypeBindingSyntax GenerateTypeBinding()
            => SyntaxFactory.TypeBinding(SyntaxFactory.Token(SyntaxKind.ColonToken), GenerateSimpleTypeName());

        private static SimpleTypeNameSyntax GenerateSimpleTypeName()
            => SyntaxFactory.SimpleTypeName(SyntaxFactory.Identifier("IdentifierToken"), default(TypeArgumentListSyntax));

        private static CompositeTypeNameSyntax GenerateCompositeTypeName()
            => SyntaxFactory.CompositeTypeName(GenerateSimpleTypeName(), SyntaxFactory.Token(SyntaxKind.DotToken), SyntaxFactory.Identifier("IdentifierToken"), default(TypeArgumentListSyntax));

        private static NilableTypeSyntax GenerateNilableType()
            => SyntaxFactory.NilableType(GenerateSimpleTypeName(), SyntaxFactory.Token(SyntaxKind.QuestionToken));

        private static ParenthesizedTypeSyntax GenerateParenthesizedType()
            => SyntaxFactory.ParenthesizedType(SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), GenerateSimpleTypeName(), SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        private static TypePackSyntax GenerateTypePack()
            => SyntaxFactory.TypePack(SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), SeparatedSyntaxList<TypeSyntax>(), SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        private static FunctionTypeSyntax GenerateFunctionType()
            => SyntaxFactory.FunctionType(default(TypeParameterListSyntax), SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), SeparatedSyntaxList<TypeSyntax>(), SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken), SyntaxFactory.Token(SyntaxKind.MinusGreaterThanToken), GenerateSimpleTypeName());

        private static ArrayTypeSyntax GenerateArrayType()
            => SyntaxFactory.ArrayType(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), GenerateSimpleTypeName(), SyntaxFactory.Token(SyntaxKind.CloseBraceToken));

        private static TableTypeIndexerSyntax GenerateTableTypeIndexer()
            => SyntaxFactory.TableTypeIndexer(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), GenerateSimpleTypeName(), SyntaxFactory.Token(SyntaxKind.CloseBracketToken), SyntaxFactory.Token(SyntaxKind.ColonToken), GenerateSimpleTypeName());

        private static TableTypePropertySyntax GenerateTableTypeProperty()
            => SyntaxFactory.TableTypeProperty(SyntaxFactory.Identifier("Identifier"), SyntaxFactory.Token(SyntaxKind.ColonToken), GenerateSimpleTypeName());

        private static TableTypeSyntax GenerateTableType()
            => SyntaxFactory.TableType(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), SeparatedSyntaxList<TableTypeElementSyntax>(), SyntaxFactory.Token(SyntaxKind.CloseBraceToken));

        private static TypeCastExpressionSyntax GenerateTypeCastExpression()
            => SyntaxFactory.TypeCastExpression(GenerateAnonymousFunctionExpression(), SyntaxFactory.Token(SyntaxKind.ColonColonToken), GenerateSimpleTypeName());

        private static UnionTypeSyntax GenerateUnionType()
            => SyntaxFactory.UnionType(GenerateSimpleTypeName(), SyntaxFactory.Token(SyntaxKind.PipeToken), GenerateSimpleTypeName());

        private static IntersectionTypeSyntax GenerateIntersectionType()
            => SyntaxFactory.IntersectionType(GenerateSimpleTypeName(), SyntaxFactory.Token(SyntaxKind.AmpersandToken), GenerateSimpleTypeName());

        private static EqualsTypeSyntax GenerateEqualsType()
            => SyntaxFactory.EqualsType(SyntaxFactory.Token(SyntaxKind.EqualsToken), GenerateSimpleTypeName());

        private static TypeParameterSyntax GenerateTypeParameter()
            => SyntaxFactory.TypeParameter(SyntaxFactory.Identifier("Identifier"), default(SyntaxToken), default(EqualsTypeSyntax));

        private static TypeParameterListSyntax GenerateTypeParameterList()
            => SyntaxFactory.TypeParameterList(SyntaxFactory.Token(SyntaxKind.LessThanToken), SeparatedSyntaxList<TypeParameterSyntax>(), SyntaxFactory.Token(SyntaxKind.GreaterThanToken));

        private static TypeArgumentListSyntax GenerateTypeArgumentList()
            => SyntaxFactory.TypeArgumentList(SyntaxFactory.Token(SyntaxKind.LessThanToken), SeparatedSyntaxList<TypeSyntax>(), SyntaxFactory.Token(SyntaxKind.GreaterThanToken));

        private static LiteralTypeSyntax GenerateLiteralType()
            => SyntaxFactory.LiteralType(SyntaxKind.StringType, SyntaxFactory.Literal("string", "string"));

        private static TypeofTypeSyntax GenerateTypeofType()
            => SyntaxFactory.TypeofType(SyntaxFactory.Token(SyntaxKind.TypeofKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), GenerateAnonymousFunctionExpression(), SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        private static VariadicTypePackSyntax GenerateVariadicTypePack()
            => SyntaxFactory.VariadicTypePack(SyntaxFactory.Token(SyntaxKind.DotDotDotToken), GenerateSimpleTypeName());

        private static GenericTypePackSyntax GenerateGenericTypePack()
            => SyntaxFactory.GenericTypePack(SyntaxFactory.Identifier("Identifier"), SyntaxFactory.Token(SyntaxKind.DotDotDotToken));

        private static CompilationUnitSyntax GenerateCompilationUnit()
            => SyntaxFactory.CompilationUnit(GenerateStatementList(), SyntaxFactory.Token(SyntaxKind.EndOfFileToken));
        #endregion Red Generators

        #region Red Factory and Property Tests
        [Fact]
        public void TestSkippedTokensTriviaFactoryAndProperties()
        {
            var node = GenerateSkippedTokensTrivia();

            Assert.Equal(default, node.Tokens);
            var newNode = node.WithTokens(node.Tokens);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestStatementListFactoryAndProperties()
        {
            var node = GenerateStatementList();

            Assert.Equal(default, node.Statements);
            var newNode = node.WithStatements(node.Statements);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestNamedParameterFactoryAndProperties()
        {
            var node = GenerateNamedParameter();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind());
            Assert.Null(node.TypeBinding);
            var newNode = node.WithIdentifier(node.Identifier).WithTypeBinding(node.TypeBinding);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestVarArgParameterFactoryAndProperties()
        {
            var node = GenerateVarArgParameter();

            Assert.Equal(SyntaxKind.DotDotDotToken, node.VarArgToken.Kind());
            Assert.Null(node.TypeBinding);
            var newNode = node.WithVarArgToken(node.VarArgToken).WithTypeBinding(node.TypeBinding);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestParameterListFactoryAndProperties()
        {
            var node = GenerateParameterList();

            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind());
            Assert.Equal(default, node.Parameters);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind());
            var newNode = node.WithOpenParenthesisToken(node.OpenParenthesisToken).WithParameters(node.Parameters).WithCloseParenthesisToken(node.CloseParenthesisToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestIdentifierKeyedTableFieldFactoryAndProperties()
        {
            var node = GenerateIdentifierKeyedTableField();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind());
            Assert.Equal(SyntaxKind.EqualsToken, node.EqualsToken.Kind());
            Assert.NotNull(node.Value);
            var newNode = node.WithIdentifier(node.Identifier).WithEqualsToken(node.EqualsToken).WithValue(node.Value);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestExpressionKeyedTableFieldFactoryAndProperties()
        {
            var node = GenerateExpressionKeyedTableField();

            Assert.Equal(SyntaxKind.OpenBracketToken, node.OpenBracketToken.Kind());
            Assert.NotNull(node.Key);
            Assert.Equal(SyntaxKind.CloseBracketToken, node.CloseBracketToken.Kind());
            Assert.Equal(SyntaxKind.EqualsToken, node.EqualsToken.Kind());
            Assert.NotNull(node.Value);
            var newNode = node.WithOpenBracketToken(node.OpenBracketToken).WithKey(node.Key).WithCloseBracketToken(node.CloseBracketToken).WithEqualsToken(node.EqualsToken).WithValue(node.Value);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestUnkeyedTableFieldFactoryAndProperties()
        {
            var node = GenerateUnkeyedTableField();

            Assert.NotNull(node.Value);
            var newNode = node.WithValue(node.Value);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestSimpleFunctionNameFactoryAndProperties()
        {
            var node = GenerateSimpleFunctionName();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Name.Kind());
            var newNode = node.WithName(node.Name);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestMemberFunctionNameFactoryAndProperties()
        {
            var node = GenerateMemberFunctionName();

            Assert.NotNull(node.BaseName);
            Assert.Equal(SyntaxKind.DotToken, node.DotToken.Kind());
            Assert.Equal(SyntaxKind.IdentifierToken, node.Name.Kind());
            var newNode = node.WithBaseName(node.BaseName).WithDotToken(node.DotToken).WithName(node.Name);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestMethodFunctionNameFactoryAndProperties()
        {
            var node = GenerateMethodFunctionName();

            Assert.NotNull(node.BaseName);
            Assert.Equal(SyntaxKind.ColonToken, node.ColonToken.Kind());
            Assert.Equal(SyntaxKind.IdentifierToken, node.Name.Kind());
            var newNode = node.WithBaseName(node.BaseName).WithColonToken(node.ColonToken).WithName(node.Name);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestStringFunctionArgumentFactoryAndProperties()
        {
            var node = GenerateStringFunctionArgument();

            Assert.NotNull(node.Expression);
            var newNode = node.WithExpression(node.Expression);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTableConstructorFunctionArgumentFactoryAndProperties()
        {
            var node = GenerateTableConstructorFunctionArgument();

            Assert.NotNull(node.TableConstructor);
            var newNode = node.WithTableConstructor(node.TableConstructor);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestExpressionListFunctionArgumentFactoryAndProperties()
        {
            var node = GenerateExpressionListFunctionArgument();

            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind());
            Assert.Equal(default, node.Expressions);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind());
            var newNode = node.WithOpenParenthesisToken(node.OpenParenthesisToken).WithExpressions(node.Expressions).WithCloseParenthesisToken(node.CloseParenthesisToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestAnonymousFunctionExpressionFactoryAndProperties()
        {
            var node = GenerateAnonymousFunctionExpression();

            Assert.Equal(SyntaxKind.FunctionKeyword, node.FunctionKeyword.Kind());
            Assert.Null(node.TypeParameterList);
            Assert.NotNull(node.Parameters);
            Assert.Null(node.TypeBinding);
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind());
            var newNode = node.WithFunctionKeyword(node.FunctionKeyword).WithTypeParameterList(node.TypeParameterList).WithParameters(node.Parameters).WithTypeBinding(node.TypeBinding).WithBody(node.Body).WithEndKeyword(node.EndKeyword);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTableConstructorExpressionFactoryAndProperties()
        {
            var node = GenerateTableConstructorExpression();

            Assert.Equal(SyntaxKind.OpenBraceToken, node.OpenBraceToken.Kind());
            Assert.Equal(default, node.Fields);
            Assert.Equal(SyntaxKind.CloseBraceToken, node.CloseBraceToken.Kind());
            var newNode = node.WithOpenBraceToken(node.OpenBraceToken).WithFields(node.Fields).WithCloseBraceToken(node.CloseBraceToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestLiteralExpressionFactoryAndProperties()
        {
            var node = GenerateLiteralExpression();

            Assert.Equal(SyntaxKind.NumericLiteralToken, node.Token.Kind());
            var newNode = node.WithToken(node.Token);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestVarArgExpressionFactoryAndProperties()
        {
            var node = GenerateVarArgExpression();

            Assert.Equal(SyntaxKind.DotDotDotToken, node.VarArgToken.Kind());
            var newNode = node.WithVarArgToken(node.VarArgToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestIdentifierNameFactoryAndProperties()
        {
            var node = GenerateIdentifierName();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind());
            var newNode = node.WithIdentifier(node.Identifier);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestMemberAccessExpressionFactoryAndProperties()
        {
            var node = GenerateMemberAccessExpression();

            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.DotToken, node.DotSeparator.Kind());
            Assert.Equal(SyntaxKind.IdentifierToken, node.MemberName.Kind());
            var newNode = node.WithExpression(node.Expression).WithDotSeparator(node.DotSeparator).WithMemberName(node.MemberName);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestElementAccessExpressionFactoryAndProperties()
        {
            var node = GenerateElementAccessExpression();

            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.OpenBracketToken, node.OpenBracketToken.Kind());
            Assert.NotNull(node.KeyExpression);
            Assert.Equal(SyntaxKind.CloseBracketToken, node.CloseBracketToken.Kind());
            var newNode = node.WithExpression(node.Expression).WithOpenBracketToken(node.OpenBracketToken).WithKeyExpression(node.KeyExpression).WithCloseBracketToken(node.CloseBracketToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestUnaryExpressionFactoryAndProperties()
        {
            var node = GenerateUnaryExpression();

            Assert.Equal(SyntaxKind.BangToken, node.OperatorToken.Kind());
            Assert.NotNull(node.Operand);
            var newNode = node.WithOperatorToken(node.OperatorToken).WithOperand(node.Operand);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestBinaryExpressionFactoryAndProperties()
        {
            var node = GenerateBinaryExpression();

            Assert.NotNull(node.Left);
            Assert.Equal(SyntaxKind.AmpersandAmpersandToken, node.OperatorToken.Kind());
            Assert.NotNull(node.Right);
            var newNode = node.WithLeft(node.Left).WithOperatorToken(node.OperatorToken).WithRight(node.Right);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestElseIfExpressionClauseFactoryAndProperties()
        {
            var node = GenerateElseIfExpressionClause();

            Assert.Equal(SyntaxKind.ElseIfKeyword, node.ElseIfKeyword.Kind());
            Assert.NotNull(node.Condition);
            Assert.Equal(SyntaxKind.ThenKeyword, node.ThenKeyword.Kind());
            Assert.NotNull(node.Value);
            var newNode = node.WithElseIfKeyword(node.ElseIfKeyword).WithCondition(node.Condition).WithThenKeyword(node.ThenKeyword).WithValue(node.Value);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestIfExpressionFactoryAndProperties()
        {
            var node = GenerateIfExpression();

            Assert.Equal(SyntaxKind.IfKeyword, node.IfKeyword.Kind());
            Assert.NotNull(node.Condition);
            Assert.Equal(SyntaxKind.ThenKeyword, node.ThenKeyword.Kind());
            Assert.NotNull(node.TrueValue);
            Assert.Equal(default, node.ElseIfClauses);
            Assert.Equal(SyntaxKind.ElseKeyword, node.ElseKeyword.Kind());
            Assert.NotNull(node.FalseValue);
            var newNode = node.WithIfKeyword(node.IfKeyword).WithCondition(node.Condition).WithThenKeyword(node.ThenKeyword).WithTrueValue(node.TrueValue).WithElseIfClauses(node.ElseIfClauses).WithElseKeyword(node.ElseKeyword).WithFalseValue(node.FalseValue);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestParenthesizedExpressionFactoryAndProperties()
        {
            var node = GenerateParenthesizedExpression();

            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind());
            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind());
            var newNode = node.WithOpenParenthesisToken(node.OpenParenthesisToken).WithExpression(node.Expression).WithCloseParenthesisToken(node.CloseParenthesisToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestFunctionCallExpressionFactoryAndProperties()
        {
            var node = GenerateFunctionCallExpression();

            Assert.NotNull(node.Expression);
            Assert.NotNull(node.Argument);
            var newNode = node.WithExpression(node.Expression).WithArgument(node.Argument);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestMethodCallExpressionFactoryAndProperties()
        {
            var node = GenerateMethodCallExpression();

            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.ColonToken, node.ColonToken.Kind());
            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind());
            Assert.NotNull(node.Argument);
            var newNode = node.WithExpression(node.Expression).WithColonToken(node.ColonToken).WithIdentifier(node.Identifier).WithArgument(node.Argument);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestVariableAttributeFactoryAndProperties()
        {
            var node = GenerateVariableAttribute();

            Assert.Equal(SyntaxKind.LessThanToken, node.LessThanToken.Kind());
            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind());
            Assert.Equal(SyntaxKind.GreaterThanToken, node.GreaterThanToken.Kind());
            var newNode = node.WithLessThanToken(node.LessThanToken).WithIdentifier(node.Identifier).WithGreaterThanToken(node.GreaterThanToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestLocalDeclarationNameFactoryAndProperties()
        {
            var node = GenerateLocalDeclarationName();

            Assert.NotNull(node.IdentifierName);
            Assert.Null(node.Attribute);
            Assert.Null(node.TypeBinding);
            var newNode = node.WithIdentifierName(node.IdentifierName).WithAttribute(node.Attribute).WithTypeBinding(node.TypeBinding);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestEqualsValuesClauseFactoryAndProperties()
        {
            var node = GenerateEqualsValuesClause();

            Assert.Equal(SyntaxKind.EqualsToken, node.EqualsToken.Kind());
            Assert.Equal(1, node.Values.Count);
            var newNode = node.WithEqualsToken(node.EqualsToken).WithValues(node.Values);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestAssignmentStatementFactoryAndProperties()
        {
            var node = GenerateAssignmentStatement();

            Assert.Equal(1, node.Variables.Count);
            Assert.NotNull(node.EqualsValues);
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithVariables(node.Variables).WithEqualsValues(node.EqualsValues).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestCompoundAssignmentStatementFactoryAndProperties()
        {
            var node = GenerateCompoundAssignmentStatement();

            Assert.NotNull(node.Variable);
            Assert.Equal(SyntaxKind.PlusEqualsToken, node.AssignmentOperatorToken.Kind());
            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithVariable(node.Variable).WithAssignmentOperatorToken(node.AssignmentOperatorToken).WithExpression(node.Expression).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestLocalVariableDeclarationStatementFactoryAndProperties()
        {
            var node = GenerateLocalVariableDeclarationStatement();

            Assert.Equal(SyntaxKind.LocalKeyword, node.LocalKeyword.Kind());
            Assert.Equal(1, node.Names.Count);
            Assert.Null(node.EqualsValues);
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithLocalKeyword(node.LocalKeyword).WithNames(node.Names).WithEqualsValues(node.EqualsValues).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTypedIdentifierNameFactoryAndProperties()
        {
            var node = GenerateTypedIdentifierName();

            Assert.NotNull(node.IdentifierName);
            Assert.Null(node.TypeBinding);
            var newNode = node.WithIdentifierName(node.IdentifierName).WithTypeBinding(node.TypeBinding);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestNumericForStatementFactoryAndProperties()
        {
            var node = GenerateNumericForStatement();

            Assert.Equal(SyntaxKind.ForKeyword, node.ForKeyword.Kind());
            Assert.NotNull(node.Identifier);
            Assert.Equal(SyntaxKind.EqualsToken, node.EqualsToken.Kind());
            Assert.NotNull(node.InitialValue);
            Assert.Equal(SyntaxKind.CommaToken, node.FinalValueCommaToken.Kind());
            Assert.NotNull(node.FinalValue);
            Assert.Equal(SyntaxKind.None, node.StepValueCommaToken.Kind());
            Assert.Null(node.StepValue);
            Assert.Equal(SyntaxKind.DoKeyword, node.DoKeyword.Kind());
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind());
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithForKeyword(node.ForKeyword).WithIdentifier(node.Identifier).WithEqualsToken(node.EqualsToken).WithInitialValue(node.InitialValue).WithFinalValueCommaToken(node.FinalValueCommaToken).WithFinalValue(node.FinalValue).WithStepValueCommaToken(node.StepValueCommaToken).WithStepValue(node.StepValue).WithDoKeyword(node.DoKeyword).WithBody(node.Body).WithEndKeyword(node.EndKeyword).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestGenericForStatementFactoryAndProperties()
        {
            var node = GenerateGenericForStatement();

            Assert.Equal(SyntaxKind.ForKeyword, node.ForKeyword.Kind());
            Assert.Equal(1, node.Identifiers.Count);
            Assert.Equal(SyntaxKind.InKeyword, node.InKeyword.Kind());
            Assert.Equal(1, node.Expressions.Count);
            Assert.Equal(SyntaxKind.DoKeyword, node.DoKeyword.Kind());
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind());
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithForKeyword(node.ForKeyword).WithIdentifiers(node.Identifiers).WithInKeyword(node.InKeyword).WithExpressions(node.Expressions).WithDoKeyword(node.DoKeyword).WithBody(node.Body).WithEndKeyword(node.EndKeyword).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestWhileStatementFactoryAndProperties()
        {
            var node = GenerateWhileStatement();

            Assert.Equal(SyntaxKind.WhileKeyword, node.WhileKeyword.Kind());
            Assert.NotNull(node.Condition);
            Assert.Equal(SyntaxKind.DoKeyword, node.DoKeyword.Kind());
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind());
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithWhileKeyword(node.WhileKeyword).WithCondition(node.Condition).WithDoKeyword(node.DoKeyword).WithBody(node.Body).WithEndKeyword(node.EndKeyword).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestRepeatUntilStatementFactoryAndProperties()
        {
            var node = GenerateRepeatUntilStatement();

            Assert.Equal(SyntaxKind.RepeatKeyword, node.RepeatKeyword.Kind());
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.UntilKeyword, node.UntilKeyword.Kind());
            Assert.NotNull(node.Condition);
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithRepeatKeyword(node.RepeatKeyword).WithBody(node.Body).WithUntilKeyword(node.UntilKeyword).WithCondition(node.Condition).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestIfStatementFactoryAndProperties()
        {
            var node = GenerateIfStatement();

            Assert.Equal(SyntaxKind.IfKeyword, node.IfKeyword.Kind());
            Assert.NotNull(node.Condition);
            Assert.Equal(SyntaxKind.ThenKeyword, node.ThenKeyword.Kind());
            Assert.NotNull(node.Body);
            Assert.Equal(default, node.ElseIfClauses);
            Assert.Null(node.ElseClause);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind());
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithIfKeyword(node.IfKeyword).WithCondition(node.Condition).WithThenKeyword(node.ThenKeyword).WithBody(node.Body).WithElseIfClauses(node.ElseIfClauses).WithElseClause(node.ElseClause).WithEndKeyword(node.EndKeyword).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestElseIfClauseFactoryAndProperties()
        {
            var node = GenerateElseIfClause();

            Assert.Equal(SyntaxKind.ElseIfKeyword, node.ElseIfKeyword.Kind());
            Assert.NotNull(node.Condition);
            Assert.Equal(SyntaxKind.ThenKeyword, node.ThenKeyword.Kind());
            Assert.NotNull(node.Body);
            var newNode = node.WithElseIfKeyword(node.ElseIfKeyword).WithCondition(node.Condition).WithThenKeyword(node.ThenKeyword).WithBody(node.Body);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestElseClauseFactoryAndProperties()
        {
            var node = GenerateElseClause();

            Assert.Equal(SyntaxKind.ElseKeyword, node.ElseKeyword.Kind());
            Assert.NotNull(node.ElseBody);
            var newNode = node.WithElseKeyword(node.ElseKeyword).WithElseBody(node.ElseBody);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestGotoStatementFactoryAndProperties()
        {
            var node = GenerateGotoStatement();

            Assert.Equal(SyntaxKind.GotoKeyword, node.GotoKeyword.Kind());
            Assert.Equal(SyntaxKind.IdentifierToken, node.LabelName.Kind());
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithGotoKeyword(node.GotoKeyword).WithLabelName(node.LabelName).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestBreakStatementFactoryAndProperties()
        {
            var node = GenerateBreakStatement();

            Assert.Equal(SyntaxKind.BreakKeyword, node.BreakKeyword.Kind());
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithBreakKeyword(node.BreakKeyword).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestReturnStatementFactoryAndProperties()
        {
            var node = GenerateReturnStatement();

            Assert.Equal(SyntaxKind.ReturnKeyword, node.ReturnKeyword.Kind());
            Assert.Equal(default, node.Expressions);
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithReturnKeyword(node.ReturnKeyword).WithExpressions(node.Expressions).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestContinueStatementFactoryAndProperties()
        {
            var node = GenerateContinueStatement();

            Assert.Equal(SyntaxKind.ContinueKeyword, node.ContinueKeyword.Kind());
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithContinueKeyword(node.ContinueKeyword).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestLocalFunctionDeclarationStatementFactoryAndProperties()
        {
            var node = GenerateLocalFunctionDeclarationStatement();

            Assert.Equal(SyntaxKind.LocalKeyword, node.LocalKeyword.Kind());
            Assert.Equal(SyntaxKind.FunctionKeyword, node.FunctionKeyword.Kind());
            Assert.NotNull(node.Name);
            Assert.Null(node.TypeParameterList);
            Assert.NotNull(node.Parameters);
            Assert.Null(node.TypeBinding);
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind());
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithLocalKeyword(node.LocalKeyword).WithFunctionKeyword(node.FunctionKeyword).WithName(node.Name).WithTypeParameterList(node.TypeParameterList).WithParameters(node.Parameters).WithTypeBinding(node.TypeBinding).WithBody(node.Body).WithEndKeyword(node.EndKeyword).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestFunctionDeclarationStatementFactoryAndProperties()
        {
            var node = GenerateFunctionDeclarationStatement();

            Assert.Equal(SyntaxKind.FunctionKeyword, node.FunctionKeyword.Kind());
            Assert.NotNull(node.Name);
            Assert.Null(node.TypeParameterList);
            Assert.NotNull(node.Parameters);
            Assert.Null(node.TypeBinding);
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind());
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithFunctionKeyword(node.FunctionKeyword).WithName(node.Name).WithTypeParameterList(node.TypeParameterList).WithParameters(node.Parameters).WithTypeBinding(node.TypeBinding).WithBody(node.Body).WithEndKeyword(node.EndKeyword).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestDoStatementFactoryAndProperties()
        {
            var node = GenerateDoStatement();

            Assert.Equal(SyntaxKind.DoKeyword, node.DoKeyword.Kind());
            Assert.NotNull(node.Body);
            Assert.Equal(SyntaxKind.EndKeyword, node.EndKeyword.Kind());
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithDoKeyword(node.DoKeyword).WithBody(node.Body).WithEndKeyword(node.EndKeyword).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestGotoLabelStatementFactoryAndProperties()
        {
            var node = GenerateGotoLabelStatement();

            Assert.Equal(SyntaxKind.ColonColonToken, node.LeftDelimiterToken.Kind());
            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind());
            Assert.Equal(SyntaxKind.ColonColonToken, node.RightDelimiterToken.Kind());
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithLeftDelimiterToken(node.LeftDelimiterToken).WithIdentifier(node.Identifier).WithRightDelimiterToken(node.RightDelimiterToken).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestExpressionStatementFactoryAndProperties()
        {
            var node = GenerateExpressionStatement();

            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithExpression(node.Expression).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestEmptyStatementFactoryAndProperties()
        {
            var node = GenerateEmptyStatement();

            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTypeDeclarationStatementFactoryAndProperties()
        {
            var node = GenerateTypeDeclarationStatement();

            Assert.Equal(SyntaxKind.None, node.ExportKeyword.Kind());
            Assert.Equal(SyntaxKind.TypeKeyword, node.TypeKeyword.Kind());
            Assert.Equal(SyntaxKind.IdentifierToken, node.Name.Kind());
            Assert.Null(node.TypeParameterList);
            Assert.Equal(SyntaxKind.EqualsToken, node.EqualsToken.Kind());
            Assert.NotNull(node.Type);
            Assert.Equal(SyntaxKind.None, node.SemicolonToken.Kind());
            var newNode = node.WithExportKeyword(node.ExportKeyword).WithTypeKeyword(node.TypeKeyword).WithName(node.Name).WithTypeParameterList(node.TypeParameterList).WithEqualsToken(node.EqualsToken).WithType(node.Type).WithSemicolonToken(node.SemicolonToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTypeBindingFactoryAndProperties()
        {
            var node = GenerateTypeBinding();

            Assert.Equal(SyntaxKind.ColonToken, node.ColonToken.Kind());
            Assert.NotNull(node.Type);
            var newNode = node.WithColonToken(node.ColonToken).WithType(node.Type);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestSimpleTypeNameFactoryAndProperties()
        {
            var node = GenerateSimpleTypeName();

            Assert.Equal(SyntaxKind.IdentifierToken, node.IdentifierToken.Kind());
            Assert.Null(node.TypeArgumentList);
            var newNode = node.WithIdentifierToken(node.IdentifierToken).WithTypeArgumentList(node.TypeArgumentList);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestCompositeTypeNameFactoryAndProperties()
        {
            var node = GenerateCompositeTypeName();

            Assert.NotNull(node.Base);
            Assert.Equal(SyntaxKind.DotToken, node.DotToken.Kind());
            Assert.Equal(SyntaxKind.IdentifierToken, node.IdentifierToken.Kind());
            Assert.Null(node.TypeArgumentList);
            var newNode = node.WithBase(node.Base).WithDotToken(node.DotToken).WithIdentifierToken(node.IdentifierToken).WithTypeArgumentList(node.TypeArgumentList);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestNilableTypeFactoryAndProperties()
        {
            var node = GenerateNilableType();

            Assert.NotNull(node.Type);
            Assert.Equal(SyntaxKind.QuestionToken, node.QuestionToken.Kind());
            var newNode = node.WithType(node.Type).WithQuestionToken(node.QuestionToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestParenthesizedTypeFactoryAndProperties()
        {
            var node = GenerateParenthesizedType();

            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind());
            Assert.NotNull(node.Type);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind());
            var newNode = node.WithOpenParenthesisToken(node.OpenParenthesisToken).WithType(node.Type).WithCloseParenthesisToken(node.CloseParenthesisToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTypePackFactoryAndProperties()
        {
            var node = GenerateTypePack();

            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind());
            Assert.Equal(default, node.Types);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind());
            var newNode = node.WithOpenParenthesisToken(node.OpenParenthesisToken).WithTypes(node.Types).WithCloseParenthesisToken(node.CloseParenthesisToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestFunctionTypeFactoryAndProperties()
        {
            var node = GenerateFunctionType();

            Assert.Null(node.TypeParameterList);
            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind());
            Assert.Equal(default, node.Parameters);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind());
            Assert.Equal(SyntaxKind.MinusGreaterThanToken, node.MinusGreaterThanToken.Kind());
            Assert.NotNull(node.ReturnType);
            var newNode = node.WithTypeParameterList(node.TypeParameterList).WithOpenParenthesisToken(node.OpenParenthesisToken).WithParameters(node.Parameters).WithCloseParenthesisToken(node.CloseParenthesisToken).WithMinusGreaterThanToken(node.MinusGreaterThanToken).WithReturnType(node.ReturnType);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestArrayTypeFactoryAndProperties()
        {
            var node = GenerateArrayType();

            Assert.Equal(SyntaxKind.OpenBraceToken, node.OpenBraceToken.Kind());
            Assert.NotNull(node.Type);
            Assert.Equal(SyntaxKind.CloseBraceToken, node.CloseBraceToken.Kind());
            var newNode = node.WithOpenBraceToken(node.OpenBraceToken).WithType(node.Type).WithCloseBraceToken(node.CloseBraceToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTableTypeIndexerFactoryAndProperties()
        {
            var node = GenerateTableTypeIndexer();

            Assert.Equal(SyntaxKind.OpenBracketToken, node.OpenBracketToken.Kind());
            Assert.NotNull(node.IndexType);
            Assert.Equal(SyntaxKind.CloseBracketToken, node.CloseBracketToken.Kind());
            Assert.Equal(SyntaxKind.ColonToken, node.ColonToken.Kind());
            Assert.NotNull(node.ValueType);
            var newNode = node.WithOpenBracketToken(node.OpenBracketToken).WithIndexType(node.IndexType).WithCloseBracketToken(node.CloseBracketToken).WithColonToken(node.ColonToken).WithValueType(node.ValueType);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTableTypePropertyFactoryAndProperties()
        {
            var node = GenerateTableTypeProperty();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind());
            Assert.Equal(SyntaxKind.ColonToken, node.ColonToken.Kind());
            Assert.NotNull(node.ValueType);
            var newNode = node.WithIdentifier(node.Identifier).WithColonToken(node.ColonToken).WithValueType(node.ValueType);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTableTypeFactoryAndProperties()
        {
            var node = GenerateTableType();

            Assert.Equal(SyntaxKind.OpenBraceToken, node.OpenBraceToken.Kind());
            Assert.Equal(default, node.Elements);
            Assert.Equal(SyntaxKind.CloseBraceToken, node.CloseBraceToken.Kind());
            var newNode = node.WithOpenBraceToken(node.OpenBraceToken).WithElements(node.Elements).WithCloseBraceToken(node.CloseBraceToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTypeCastExpressionFactoryAndProperties()
        {
            var node = GenerateTypeCastExpression();

            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.ColonColonToken, node.ColonColonToken.Kind());
            Assert.NotNull(node.Type);
            var newNode = node.WithExpression(node.Expression).WithColonColonToken(node.ColonColonToken).WithType(node.Type);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestUnionTypeFactoryAndProperties()
        {
            var node = GenerateUnionType();

            Assert.NotNull(node.Left);
            Assert.Equal(SyntaxKind.PipeToken, node.PipeToken.Kind());
            Assert.NotNull(node.Right);
            var newNode = node.WithLeft(node.Left).WithPipeToken(node.PipeToken).WithRight(node.Right);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestIntersectionTypeFactoryAndProperties()
        {
            var node = GenerateIntersectionType();

            Assert.NotNull(node.Left);
            Assert.Equal(SyntaxKind.AmpersandToken, node.AmpersandToken.Kind());
            Assert.NotNull(node.Right);
            var newNode = node.WithLeft(node.Left).WithAmpersandToken(node.AmpersandToken).WithRight(node.Right);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestEqualsTypeFactoryAndProperties()
        {
            var node = GenerateEqualsType();

            Assert.Equal(SyntaxKind.EqualsToken, node.EqualsToken.Kind());
            Assert.NotNull(node.Type);
            var newNode = node.WithEqualsToken(node.EqualsToken).WithType(node.Type);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTypeParameterFactoryAndProperties()
        {
            var node = GenerateTypeParameter();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind());
            Assert.Equal(SyntaxKind.None, node.DotDotDotToken.Kind());
            Assert.Null(node.EqualsType);
            var newNode = node.WithIdentifier(node.Identifier).WithDotDotDotToken(node.DotDotDotToken).WithEqualsType(node.EqualsType);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTypeParameterListFactoryAndProperties()
        {
            var node = GenerateTypeParameterList();

            Assert.Equal(SyntaxKind.LessThanToken, node.LessThanToken.Kind());
            Assert.Equal(default, node.Names);
            Assert.Equal(SyntaxKind.GreaterThanToken, node.GreaterThanToken.Kind());
            var newNode = node.WithLessThanToken(node.LessThanToken).WithNames(node.Names).WithGreaterThanToken(node.GreaterThanToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTypeArgumentListFactoryAndProperties()
        {
            var node = GenerateTypeArgumentList();

            Assert.Equal(SyntaxKind.LessThanToken, node.LessThanToken.Kind());
            Assert.Equal(default, node.Arguments);
            Assert.Equal(SyntaxKind.GreaterThanToken, node.GreaterThanToken.Kind());
            var newNode = node.WithLessThanToken(node.LessThanToken).WithArguments(node.Arguments).WithGreaterThanToken(node.GreaterThanToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestLiteralTypeFactoryAndProperties()
        {
            var node = GenerateLiteralType();

            Assert.Equal(SyntaxKind.StringLiteralToken, node.Token.Kind());
            var newNode = node.WithToken(node.Token);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestTypeofTypeFactoryAndProperties()
        {
            var node = GenerateTypeofType();

            Assert.Equal(SyntaxKind.TypeofKeyword, node.TypeofKeyword.Kind());
            Assert.Equal(SyntaxKind.OpenParenthesisToken, node.OpenParenthesisToken.Kind());
            Assert.NotNull(node.Expression);
            Assert.Equal(SyntaxKind.CloseParenthesisToken, node.CloseParenthesisToken.Kind());
            var newNode = node.WithTypeofKeyword(node.TypeofKeyword).WithOpenParenthesisToken(node.OpenParenthesisToken).WithExpression(node.Expression).WithCloseParenthesisToken(node.CloseParenthesisToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestVariadicTypePackFactoryAndProperties()
        {
            var node = GenerateVariadicTypePack();

            Assert.Equal(SyntaxKind.DotDotDotToken, node.DotDotDotToken.Kind());
            Assert.NotNull(node.Type);
            var newNode = node.WithDotDotDotToken(node.DotDotDotToken).WithType(node.Type);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestGenericTypePackFactoryAndProperties()
        {
            var node = GenerateGenericTypePack();

            Assert.Equal(SyntaxKind.IdentifierToken, node.Identifier.Kind());
            Assert.Equal(SyntaxKind.DotDotDotToken, node.DotDotDotToken.Kind());
            var newNode = node.WithIdentifier(node.Identifier).WithDotDotDotToken(node.DotDotDotToken);
            Assert.Equal(node, newNode);
        }

        [Fact]
        public void TestCompilationUnitFactoryAndProperties()
        {
            var node = GenerateCompilationUnit();

            Assert.NotNull(node.Statements);
            Assert.Equal(SyntaxKind.EndOfFileToken, node.EndOfFileToken.Kind());
            var newNode = node.WithStatements(node.Statements).WithEndOfFileToken(node.EndOfFileToken);
            Assert.Equal(node, newNode);
        }
        #endregion Red Factory and Property Tests

        #region Red Rewriters
        [Fact]
        public void TestSkippedTokensTriviaTokenDeleteRewriter()
        {
            var oldNode = GenerateSkippedTokensTrivia();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestSkippedTokensTriviaIdentityRewriter()
        {
            var oldNode = GenerateSkippedTokensTrivia();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestStatementListTokenDeleteRewriter()
        {
            var oldNode = GenerateStatementList();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestStatementListIdentityRewriter()
        {
            var oldNode = GenerateStatementList();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestNamedParameterTokenDeleteRewriter()
        {
            var oldNode = GenerateNamedParameter();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestNamedParameterIdentityRewriter()
        {
            var oldNode = GenerateNamedParameter();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestVarArgParameterTokenDeleteRewriter()
        {
            var oldNode = GenerateVarArgParameter();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestVarArgParameterIdentityRewriter()
        {
            var oldNode = GenerateVarArgParameter();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestParameterListTokenDeleteRewriter()
        {
            var oldNode = GenerateParameterList();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestParameterListIdentityRewriter()
        {
            var oldNode = GenerateParameterList();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestIdentifierKeyedTableFieldTokenDeleteRewriter()
        {
            var oldNode = GenerateIdentifierKeyedTableField();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestIdentifierKeyedTableFieldIdentityRewriter()
        {
            var oldNode = GenerateIdentifierKeyedTableField();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestExpressionKeyedTableFieldTokenDeleteRewriter()
        {
            var oldNode = GenerateExpressionKeyedTableField();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestExpressionKeyedTableFieldIdentityRewriter()
        {
            var oldNode = GenerateExpressionKeyedTableField();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestUnkeyedTableFieldTokenDeleteRewriter()
        {
            var oldNode = GenerateUnkeyedTableField();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestUnkeyedTableFieldIdentityRewriter()
        {
            var oldNode = GenerateUnkeyedTableField();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestSimpleFunctionNameTokenDeleteRewriter()
        {
            var oldNode = GenerateSimpleFunctionName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestSimpleFunctionNameIdentityRewriter()
        {
            var oldNode = GenerateSimpleFunctionName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestMemberFunctionNameTokenDeleteRewriter()
        {
            var oldNode = GenerateMemberFunctionName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestMemberFunctionNameIdentityRewriter()
        {
            var oldNode = GenerateMemberFunctionName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestMethodFunctionNameTokenDeleteRewriter()
        {
            var oldNode = GenerateMethodFunctionName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestMethodFunctionNameIdentityRewriter()
        {
            var oldNode = GenerateMethodFunctionName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestStringFunctionArgumentTokenDeleteRewriter()
        {
            var oldNode = GenerateStringFunctionArgument();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestStringFunctionArgumentIdentityRewriter()
        {
            var oldNode = GenerateStringFunctionArgument();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTableConstructorFunctionArgumentTokenDeleteRewriter()
        {
            var oldNode = GenerateTableConstructorFunctionArgument();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTableConstructorFunctionArgumentIdentityRewriter()
        {
            var oldNode = GenerateTableConstructorFunctionArgument();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestExpressionListFunctionArgumentTokenDeleteRewriter()
        {
            var oldNode = GenerateExpressionListFunctionArgument();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestExpressionListFunctionArgumentIdentityRewriter()
        {
            var oldNode = GenerateExpressionListFunctionArgument();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestAnonymousFunctionExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateAnonymousFunctionExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestAnonymousFunctionExpressionIdentityRewriter()
        {
            var oldNode = GenerateAnonymousFunctionExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTableConstructorExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateTableConstructorExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTableConstructorExpressionIdentityRewriter()
        {
            var oldNode = GenerateTableConstructorExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestLiteralExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateLiteralExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestLiteralExpressionIdentityRewriter()
        {
            var oldNode = GenerateLiteralExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestVarArgExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateVarArgExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestVarArgExpressionIdentityRewriter()
        {
            var oldNode = GenerateVarArgExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestIdentifierNameTokenDeleteRewriter()
        {
            var oldNode = GenerateIdentifierName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestIdentifierNameIdentityRewriter()
        {
            var oldNode = GenerateIdentifierName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestMemberAccessExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateMemberAccessExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestMemberAccessExpressionIdentityRewriter()
        {
            var oldNode = GenerateMemberAccessExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestElementAccessExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateElementAccessExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestElementAccessExpressionIdentityRewriter()
        {
            var oldNode = GenerateElementAccessExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestUnaryExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateUnaryExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestUnaryExpressionIdentityRewriter()
        {
            var oldNode = GenerateUnaryExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestBinaryExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateBinaryExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestBinaryExpressionIdentityRewriter()
        {
            var oldNode = GenerateBinaryExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestElseIfExpressionClauseTokenDeleteRewriter()
        {
            var oldNode = GenerateElseIfExpressionClause();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestElseIfExpressionClauseIdentityRewriter()
        {
            var oldNode = GenerateElseIfExpressionClause();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestIfExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateIfExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestIfExpressionIdentityRewriter()
        {
            var oldNode = GenerateIfExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestParenthesizedExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateParenthesizedExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestParenthesizedExpressionIdentityRewriter()
        {
            var oldNode = GenerateParenthesizedExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestFunctionCallExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateFunctionCallExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestFunctionCallExpressionIdentityRewriter()
        {
            var oldNode = GenerateFunctionCallExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestMethodCallExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateMethodCallExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestMethodCallExpressionIdentityRewriter()
        {
            var oldNode = GenerateMethodCallExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestVariableAttributeTokenDeleteRewriter()
        {
            var oldNode = GenerateVariableAttribute();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestVariableAttributeIdentityRewriter()
        {
            var oldNode = GenerateVariableAttribute();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestLocalDeclarationNameTokenDeleteRewriter()
        {
            var oldNode = GenerateLocalDeclarationName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestLocalDeclarationNameIdentityRewriter()
        {
            var oldNode = GenerateLocalDeclarationName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestEqualsValuesClauseTokenDeleteRewriter()
        {
            var oldNode = GenerateEqualsValuesClause();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestEqualsValuesClauseIdentityRewriter()
        {
            var oldNode = GenerateEqualsValuesClause();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestAssignmentStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateAssignmentStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestAssignmentStatementIdentityRewriter()
        {
            var oldNode = GenerateAssignmentStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestCompoundAssignmentStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateCompoundAssignmentStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestCompoundAssignmentStatementIdentityRewriter()
        {
            var oldNode = GenerateCompoundAssignmentStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestLocalVariableDeclarationStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateLocalVariableDeclarationStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestLocalVariableDeclarationStatementIdentityRewriter()
        {
            var oldNode = GenerateLocalVariableDeclarationStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypedIdentifierNameTokenDeleteRewriter()
        {
            var oldNode = GenerateTypedIdentifierName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypedIdentifierNameIdentityRewriter()
        {
            var oldNode = GenerateTypedIdentifierName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestNumericForStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateNumericForStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestNumericForStatementIdentityRewriter()
        {
            var oldNode = GenerateNumericForStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestGenericForStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateGenericForStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestGenericForStatementIdentityRewriter()
        {
            var oldNode = GenerateGenericForStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestWhileStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateWhileStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestWhileStatementIdentityRewriter()
        {
            var oldNode = GenerateWhileStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestRepeatUntilStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateRepeatUntilStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestRepeatUntilStatementIdentityRewriter()
        {
            var oldNode = GenerateRepeatUntilStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestIfStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateIfStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestIfStatementIdentityRewriter()
        {
            var oldNode = GenerateIfStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestElseIfClauseTokenDeleteRewriter()
        {
            var oldNode = GenerateElseIfClause();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestElseIfClauseIdentityRewriter()
        {
            var oldNode = GenerateElseIfClause();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestElseClauseTokenDeleteRewriter()
        {
            var oldNode = GenerateElseClause();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestElseClauseIdentityRewriter()
        {
            var oldNode = GenerateElseClause();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestGotoStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateGotoStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestGotoStatementIdentityRewriter()
        {
            var oldNode = GenerateGotoStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestBreakStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateBreakStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestBreakStatementIdentityRewriter()
        {
            var oldNode = GenerateBreakStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestReturnStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateReturnStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestReturnStatementIdentityRewriter()
        {
            var oldNode = GenerateReturnStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestContinueStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateContinueStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestContinueStatementIdentityRewriter()
        {
            var oldNode = GenerateContinueStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestLocalFunctionDeclarationStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateLocalFunctionDeclarationStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestLocalFunctionDeclarationStatementIdentityRewriter()
        {
            var oldNode = GenerateLocalFunctionDeclarationStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestFunctionDeclarationStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateFunctionDeclarationStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestFunctionDeclarationStatementIdentityRewriter()
        {
            var oldNode = GenerateFunctionDeclarationStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestDoStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateDoStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestDoStatementIdentityRewriter()
        {
            var oldNode = GenerateDoStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestGotoLabelStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateGotoLabelStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestGotoLabelStatementIdentityRewriter()
        {
            var oldNode = GenerateGotoLabelStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestExpressionStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateExpressionStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestExpressionStatementIdentityRewriter()
        {
            var oldNode = GenerateExpressionStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestEmptyStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateEmptyStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestEmptyStatementIdentityRewriter()
        {
            var oldNode = GenerateEmptyStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeDeclarationStatementTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeDeclarationStatement();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeDeclarationStatementIdentityRewriter()
        {
            var oldNode = GenerateTypeDeclarationStatement();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeBindingTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeBinding();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeBindingIdentityRewriter()
        {
            var oldNode = GenerateTypeBinding();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestSimpleTypeNameTokenDeleteRewriter()
        {
            var oldNode = GenerateSimpleTypeName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestSimpleTypeNameIdentityRewriter()
        {
            var oldNode = GenerateSimpleTypeName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestCompositeTypeNameTokenDeleteRewriter()
        {
            var oldNode = GenerateCompositeTypeName();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestCompositeTypeNameIdentityRewriter()
        {
            var oldNode = GenerateCompositeTypeName();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestNilableTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateNilableType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestNilableTypeIdentityRewriter()
        {
            var oldNode = GenerateNilableType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestParenthesizedTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateParenthesizedType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestParenthesizedTypeIdentityRewriter()
        {
            var oldNode = GenerateParenthesizedType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypePackTokenDeleteRewriter()
        {
            var oldNode = GenerateTypePack();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypePackIdentityRewriter()
        {
            var oldNode = GenerateTypePack();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestFunctionTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateFunctionType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestFunctionTypeIdentityRewriter()
        {
            var oldNode = GenerateFunctionType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestArrayTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateArrayType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestArrayTypeIdentityRewriter()
        {
            var oldNode = GenerateArrayType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTableTypeIndexerTokenDeleteRewriter()
        {
            var oldNode = GenerateTableTypeIndexer();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTableTypeIndexerIdentityRewriter()
        {
            var oldNode = GenerateTableTypeIndexer();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTableTypePropertyTokenDeleteRewriter()
        {
            var oldNode = GenerateTableTypeProperty();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTableTypePropertyIdentityRewriter()
        {
            var oldNode = GenerateTableTypeProperty();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTableTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateTableType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTableTypeIdentityRewriter()
        {
            var oldNode = GenerateTableType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeCastExpressionTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeCastExpression();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeCastExpressionIdentityRewriter()
        {
            var oldNode = GenerateTypeCastExpression();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestUnionTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateUnionType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestUnionTypeIdentityRewriter()
        {
            var oldNode = GenerateUnionType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestIntersectionTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateIntersectionType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestIntersectionTypeIdentityRewriter()
        {
            var oldNode = GenerateIntersectionType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestEqualsTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateEqualsType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestEqualsTypeIdentityRewriter()
        {
            var oldNode = GenerateEqualsType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeParameterTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeParameter();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeParameterIdentityRewriter()
        {
            var oldNode = GenerateTypeParameter();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeParameterListTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeParameterList();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeParameterListIdentityRewriter()
        {
            var oldNode = GenerateTypeParameterList();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeArgumentListTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeArgumentList();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeArgumentListIdentityRewriter()
        {
            var oldNode = GenerateTypeArgumentList();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestLiteralTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateLiteralType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestLiteralTypeIdentityRewriter()
        {
            var oldNode = GenerateLiteralType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestTypeofTypeTokenDeleteRewriter()
        {
            var oldNode = GenerateTypeofType();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestTypeofTypeIdentityRewriter()
        {
            var oldNode = GenerateTypeofType();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestVariadicTypePackTokenDeleteRewriter()
        {
            var oldNode = GenerateVariadicTypePack();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestVariadicTypePackIdentityRewriter()
        {
            var oldNode = GenerateVariadicTypePack();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestGenericTypePackTokenDeleteRewriter()
        {
            var oldNode = GenerateGenericTypePack();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestGenericTypePackIdentityRewriter()
        {
            var oldNode = GenerateGenericTypePack();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }

        [Fact]
        public void TestCompilationUnitTokenDeleteRewriter()
        {
            var oldNode = GenerateCompilationUnit();
            var rewriter = new TokenDeleteRewriter();
            var newNode = rewriter.Visit(oldNode);

            if (!oldNode.IsMissing)
            {
                Assert.NotEqual(oldNode, newNode);
            }

            Assert.NotNull(newNode);
            Assert.True(newNode.IsMissing, "No tokens => missing");
        }

        [Fact]
        public void TestCompilationUnitIdentityRewriter()
        {
            var oldNode = GenerateCompilationUnit();
            var rewriter = new IdentityRewriter();
            var newNode = rewriter.Visit(oldNode);

            Assert.Same(oldNode, newNode);
        }
        #endregion Red Rewriters
    }
}
