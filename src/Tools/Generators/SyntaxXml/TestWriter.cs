// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Diagnostics;

namespace Loretta.Generators.SyntaxXml
{
    internal class TestWriter : AbstractFileWriter
    {
        private TestWriter(TextWriter writer, Tree tree, CancellationToken cancellationToken = default) : base(writer, tree, cancellationToken)
        {
        }

        public static void Write(TextWriter writer, Tree tree) => new TestWriter(writer, tree).WriteFile();

        private void WriteFile()
        {
            WriteLine("// <auto-generated />");
            WriteLine();
            WriteLine("#pragma warning disable xUnit2013");
            WriteLine();
            WriteLine("using Loretta.CodeAnalysis.Lua.Syntax;");
            WriteLine("using Loretta.Utilities;");
            WriteLine("using Xunit;");
            WriteLine("using InternalSyntaxFactory = Loretta.CodeAnalysis.Lua.Syntax.InternalSyntax.SyntaxFactory;");
            WriteLine();

            WriteLine("namespace Loretta.CodeAnalysis.Lua.UnitTests");
            OpenBlock();

            WriteLine();
            WriteLine("public partial class GreenNodeTests");
            OpenBlock();

            WriteLine("#region Green Generators");
            WriteNodeGenerators(isGreen: true);
            WriteLine("#endregion Green Generators");
            WriteLine();

            WriteLine("#region Green Factory and Property Tests");
            WriteFactoryPropertyTests(isGreen: true);
            WriteLine("#endregion Green Factory and Property Tests");
            WriteLine();

            WriteLine("#region Green Rewriters");
            WriteRewriterTests();
            WriteLine("#endregion Green Rewriters");

            CloseBlock();

            WriteLine();
            WriteLine("public partial class RedNodeTests");
            OpenBlock();

            WriteLine("#region Red Generators");
            WriteNodeGenerators(isGreen: false);
            WriteLine("#endregion Red Generators");
            WriteLine();

            WriteLine("#region Red Factory and Property Tests");
            WriteFactoryPropertyTests(isGreen: false);
            WriteLine("#endregion Red Factory and Property Tests");
            WriteLine();

            WriteLine("#region Red Rewriters");
            WriteRewriterTests();
            WriteLine("#endregion Red Rewriters");

            CloseBlock();

            CloseBlock();
        }

        private void WriteNodeGenerators(bool isGreen)
        {
            var nodes = Tree.Types.Where(n => n is not (PredefinedNode or AbstractNode));
            var first = true;
            foreach (var node in nodes)
            {
                if (!first)
                {
                    WriteLine();
                }
                first = false;
                WriteNodeGenerator((Node) node, isGreen);
            }
        }

        private void WriteValue(
            bool isOptional,
            string type,
            bool isGreen,
            string internalNamespace,
            string luaNamespace,
            string syntaxFactory,
            string? kind = null,
            int minCount = 0,
            string identName = "name")
        {
            if (isOptional)
            {
                if (isGreen)
                {
                    Write("null");
                }
                else
                {
                    Write($"default({type})");
                }
            }
            else if (IsAnyList(type))
            {
                string typeName;
                bool noNew = false;
                if ((type.StartsWith("SyntaxList<") && type != "SyntaxList<SyntaxToken>")
                    || type.StartsWith("SeparatedSyntaxList<"))
                {
                    typeName = isGreen ? type.Replace("<", "<" + luaNamespace) : type;
                    noNew = true;
                }
                else if (isGreen)
                {
                    typeName = internalNamespace + type.Replace("<", "<" + luaNamespace);
                }
                else if (type == "SyntaxList<SyntaxToken>")
                {
                    typeName = "SyntaxTokenList";
                }
                else
                {
                    typeName = type;
                }

                if (!noNew)
                    Write("new ");
                Write($"{typeName}(");
                for (var idx = 0; idx < minCount; idx++)
                {
                    if (idx > 0)
                        Write(", ");
                    WriteValue(
                        false,
                        GetElementType(type),
                        isGreen,
                        internalNamespace,
                        luaNamespace,
                        syntaxFactory);
                }
                Write(")");
            }
            else if (type == "SyntaxToken")
            {
                Debug.Assert(kind is not null);
                var leadingTrivia = isGreen ? "null, " : string.Empty;
                var trailingTrivia = isGreen ? ", null" : string.Empty;
                if (kind == "IdentifierToken")
                {
                    Write($"{syntaxFactory}.Identifier(\"{identName}\")");
                }
                else if (kind == "StringLiteralToken")
                {
                    Write($"{syntaxFactory}.Literal({leadingTrivia}\"string\", \"string\"{trailingTrivia})");
                }
                else if (kind == "NumericLiteralToken")
                {
                    Write($"{syntaxFactory}.Literal({leadingTrivia}\"1\", 1{trailingTrivia})");
                }
                else
                {
                    Write($"{syntaxFactory}.Token(SyntaxKind.{kind})");
                }
            }
            else if (type == "LuaSyntaxNode")
            {
                Write($"{syntaxFactory}.IdentifierName({syntaxFactory}.Identifier(\"{identName}\"))");
            }
            else
            {
                //drill down to a concrete type
                while (true)
                {
                    var subTypes = ChildMap[type];
                    if (!subTypes.Any())
                    {
                        break;
                    }
                    type = subTypes.First();
                }
                Write($"Generate{StripPost(type, "Syntax")}()");
            }
        }
        private void WriteNodeGenerator(Node node, bool isGreen)
        {
            var valueFields = node.Fields.Where(n => !IsNodeOrNodeList(n.Type));
            var nodeFields = node.Fields.Where(n => IsNodeOrNodeList(n.Type));

            var internalNamespace = isGreen ? "Loretta.CodeAnalysis.Syntax.InternalSyntax." : "";
            var luaNamespace = isGreen ? "Syntax.InternalSyntax." : "";
            var syntaxFactory = isGreen ? "InternalSyntaxFactory" : "SyntaxFactory";

            var strippedName = StripPost(node.Name, "Syntax");

            WriteLine($"private static {luaNamespace}{node.Name} Generate{strippedName}()");

            Write($"    => {syntaxFactory}.{strippedName}(");
            //instantiate node

            var first = true;

            if (node.Kinds.Count > 1)
            {
                Write($"SyntaxKind.{node.Kinds[0].Name}"); //TODO: other kinds?
                first = false;
            }

            foreach (var field in nodeFields)
            {
                if (!first)
                {
                    Write(", ");
                }
                first = false;

                WriteValue(
                    field.Optional,
                    field.Type,
                    isGreen,
                    internalNamespace,
                    luaNamespace,
                    syntaxFactory,
                    ChooseValidKind(field, node),
                    field.MinCount,
                    field.Name);
            }

            foreach (var field in valueFields)
            {
                if (!first)
                {
                    Write(", ");
                }
                first = false;

                Write($"new {field.Type}()");
            }

            WriteLine(");");
        }

        private void WriteFactoryPropertyTests(bool isGreen)
        {
            var nodes = Tree.Types.Where(n => n is not (PredefinedNode or AbstractNode));
            var first = true;
            foreach (var node in nodes)
            {
                if (!first)
                {
                    WriteLine();
                }
                first = false;
                WriteFactoryPropertyTest((Node) node, isGreen);
            }
        }

        private void WriteFactoryPropertyTest(Node node, bool isGreen)
        {
            var valueFields = node.Fields.Where(n => !IsNodeOrNodeList(n.Type));
            var nodeFields = node.Fields.Where(n => IsNodeOrNodeList(n.Type));

            var strippedName = StripPost(node.Name, "Syntax");

            WriteLine("[Fact]");
            WriteLine($"public void Test{strippedName}FactoryAndProperties()");
            OpenBlock();

            WriteLine($"var node = Generate{strippedName}();");

            WriteLine();

            //check properties
            {
                string? withStat = null;
                foreach (var field in nodeFields)
                {
                    if (IsOptional(field))
                    {
                        if (!isGreen && field.Type == "SyntaxToken")
                        {
                            WriteLine($"Assert.Equal(SyntaxKind.None, node.{field.Name}.Kind());");
                        }
                        else
                        {
                            WriteLine($"Assert.Null(node.{field.Name});");
                        }
                    }
                    else if (field.Type == "SyntaxToken")
                    {
                        var kind = ChooseValidKind(field, node);
                        if (!isGreen)
                        {
                            WriteLine($"Assert.Equal(SyntaxKind.{kind}, node.{field.Name}.Kind());");
                        }
                        else
                        {
                            WriteLine($"Assert.Equal(SyntaxKind.{kind}, node.{field.Name}.Kind);");
                        }
                    }
                    else
                    {
                        if (field.Type == "SyntaxToken")
                        {
                            WriteLine($"Assert.NotEqual(default, node.{field.Name});");
                        }
                        else if (
                            field.Type == "SyntaxTokenList" ||
                            field.Type.StartsWith("SyntaxList<") ||
                            field.Type.StartsWith("SeparatedSyntaxList<"))
                        {
                            if (field.MinCount > 0)
                            {
                                WriteLine($"Assert.Equal({field.MinCount}, node.{field.Name}.Count);");
                            }
                            else
                            {
                                WriteLine($"Assert.Equal(default, node.{field.Name});");
                            }
                        }
                        else
                        {
                            WriteLine($"Assert.NotNull(node.{field.Name});");
                        }
                    }

                    if (!isGreen)
                    {
                        withStat += $".With{field.Name}(node.{field.Name})";
                    }
                }

                foreach (var field in valueFields)
                {
                    WriteLine($"Assert.Equal(new {field.Type}(), node.{field.Name});");
                    if (!isGreen)
                    {
                        withStat += $".With{field.Name}(node.{field.Name})";
                    }
                }

                if (!isGreen && withStat != null)
                {
                    WriteLine($"var newNode = node{withStat};");
                    WriteLine("Assert.Equal(node, newNode);");
                }
            }

            if (isGreen)
            {
                WriteLine();
                WriteLine("AttachAndCheckDiagnostics(node);");
            }

            CloseBlock();
        }

        private void WriteRewriterTests()
        {
            var nodes = Tree.Types.Where(n => n is not (PredefinedNode or AbstractNode));
            var first = true;
            foreach (var node in nodes)
            {
                if (!first)
                {
                    WriteLine();
                }
                first = false;
                WriteTokenDeleteRewriterTest((Node) node);
                WriteLine();
                WriteIdentityRewriterTest((Node) node);
            }
        }

        private void WriteTokenDeleteRewriterTest(Node node)
        {
            var valueFields = node.Fields.Where(n => !IsNodeOrNodeList(n.Type));
            var nodeFields = node.Fields.Where(n => IsNodeOrNodeList(n.Type));

            var strippedName = StripPost(node.Name, "Syntax");

            WriteLine("[Fact]");
            WriteLine($"public void Test{strippedName}TokenDeleteRewriter()");
            OpenBlock();

            WriteLine($"var oldNode = Generate{strippedName}();");
            WriteLine("var rewriter = new TokenDeleteRewriter();");
            WriteLine("var newNode = rewriter.Visit(oldNode);");

            WriteLine();
            WriteLine("if (!oldNode.IsMissing)");
            OpenBlock();
            WriteLine("Assert.NotEqual(oldNode, newNode);");
            CloseBlock();

            WriteLine();
            WriteLine("Assert.NotNull(newNode);");
            WriteLine("Assert.True(newNode.IsMissing, \"No tokens => missing\");");

            CloseBlock();
        }

        private void WriteIdentityRewriterTest(Node node)
        {
            var valueFields = node.Fields.Where(n => !IsNodeOrNodeList(n.Type));
            var nodeFields = node.Fields.Where(n => IsNodeOrNodeList(n.Type));

            var strippedName = StripPost(node.Name, "Syntax");

            WriteLine("[Fact]");
            WriteLine($"public void Test{strippedName}IdentityRewriter()");
            OpenBlock();

            WriteLine($"var oldNode = Generate{strippedName}();");
            WriteLine("var rewriter = new IdentityRewriter();");
            WriteLine("var newNode = rewriter.Visit(oldNode);");

            WriteLine();

            WriteLine("Assert.Same(oldNode, newNode);");

            CloseBlock();
        }

        //guess a reasonable kind if there are no constraints
        private string? ChooseValidKind(Field field, Node nd)
        {
            var fieldKinds = GetKindsOfFieldOrNearestParent(nd, field);
            return fieldKinds?.Count > 0 ? fieldKinds[0].Name : "IdentifierToken";
        }
    }
}
